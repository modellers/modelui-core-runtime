{"version":3,"file":"TreeUtil.js","sources":["../../../src/util/TreeUtil.js"],"sourcesContent":["// copied as is from\n// https://github.com/frontend-collective/react-sortable-tree/blob/master/src/utils/tree-data-utils.js\n\n/**\n * Performs a depth-first traversal over all of the node descendants,\n * incrementing currentIndex by 1 for each\n */\nfunction getNodeDataAtTreeIndexOrNextIndex({\n  targetIndex,\n  node,\n  currentIndex,\n  getNodeKey,\n  path = [],\n  lowerSiblingCounts = [],\n  ignoreCollapsed = true,\n  isPseudoRoot = false\n}) {\n  // The pseudo-root is not considered in the path\n  const selfPath = !isPseudoRoot\n    ? [...path, getNodeKey({ node, treeIndex: currentIndex })]\n    : []\n\n  // Return target node when found\n  if (currentIndex === targetIndex) {\n    return {\n      node,\n      lowerSiblingCounts,\n      path: selfPath\n    }\n  }\n\n  // Add one and continue for nodes with no children or hidden children\n  if (!node.children || (ignoreCollapsed && node.expanded !== true)) {\n    return { nextIndex: currentIndex + 1 }\n  }\n\n  // Iterate over each child and their descendants and return the\n  // target node if childIndex reaches the targetIndex\n  let childIndex = currentIndex + 1\n  const childCount = node.children.length\n  for (let i = 0; i < childCount; i += 1) {\n    const result = getNodeDataAtTreeIndexOrNextIndex({\n      ignoreCollapsed,\n      getNodeKey,\n      targetIndex,\n      node: node.children[i],\n      currentIndex: childIndex,\n      lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\n      path: selfPath\n    })\n\n    if (result.node) {\n      return result\n    }\n\n    childIndex = result.nextIndex\n  }\n\n  // If the target node is not found, return the farthest traversed index\n  return { nextIndex: childIndex }\n}\n\nexport function getDescendantCount({ node, ignoreCollapsed = true }) {\n  return (\n    getNodeDataAtTreeIndexOrNextIndex({\n      getNodeKey: () => {},\n      ignoreCollapsed,\n      node,\n      currentIndex: 0,\n      targetIndex: -1\n    }).nextIndex - 1\n  )\n}\n\n/**\n * Walk all descendants of the given node, depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\nfunction walkDescendants({\n  callback,\n  getNodeKey,\n  ignoreCollapsed,\n  isPseudoRoot = false,\n  node,\n  parentNode = null,\n  currentIndex,\n  path = [],\n  lowerSiblingCounts = []\n}) {\n  // The pseudo-root is not considered in the path\n  const selfPath = isPseudoRoot\n    ? []\n    : [...path, getNodeKey({ node, treeIndex: currentIndex })]\n  const selfInfo = isPseudoRoot\n    ? null\n    : {\n        node,\n        parentNode,\n        path: selfPath,\n        lowerSiblingCounts,\n        treeIndex: currentIndex\n      }\n\n  if (!isPseudoRoot) {\n    const callbackResult = callback(selfInfo)\n\n    // Cut walk short if the callback returned false\n    if (callbackResult === false) {\n      return false\n    }\n  }\n\n  // Return self on nodes with no children or hidden children\n  if (\n    !node.children ||\n    (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n  ) {\n    return currentIndex\n  }\n\n  // Get all descendants\n  let childIndex = currentIndex\n  const childCount = node.children.length\n  if (typeof node.children !== 'function') {\n    for (let i = 0; i < childCount; i += 1) {\n      childIndex = walkDescendants({\n        callback,\n        getNodeKey,\n        ignoreCollapsed,\n        node: node.children[i],\n        parentNode: isPseudoRoot ? null : node,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\n        path: selfPath\n      })\n\n      // Cut walk short if the callback returned false\n      if (childIndex === false) {\n        return false\n      }\n    }\n  }\n\n  return childIndex\n}\n\n/**\n * Perform a change on the given node and all its descendants, traversing the tree depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\nfunction mapDescendants({\n  callback,\n  getNodeKey,\n  ignoreCollapsed,\n  isPseudoRoot = false,\n  node,\n  parentNode = null,\n  currentIndex,\n  path = [],\n  lowerSiblingCounts = []\n}) {\n  const nextNode = { ...node }\n\n  // The pseudo-root is not considered in the path\n  const selfPath = isPseudoRoot\n    ? []\n    : [...path, getNodeKey({ node: nextNode, treeIndex: currentIndex })]\n  const selfInfo = {\n    node: nextNode,\n    parentNode,\n    path: selfPath,\n    lowerSiblingCounts,\n    treeIndex: currentIndex\n  }\n\n  // Return self on nodes with no children or hidden children\n  if (\n    !nextNode.children ||\n    (nextNode.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n  ) {\n    return {\n      treeIndex: currentIndex,\n      node: callback(selfInfo)\n    }\n  }\n\n  // Get all descendants\n  let childIndex = currentIndex\n  const childCount = nextNode.children.length\n  if (typeof nextNode.children !== 'function') {\n    nextNode.children = nextNode.children.map((child, i) => {\n      const mapResult = mapDescendants({\n        callback,\n        getNodeKey,\n        ignoreCollapsed,\n        node: child,\n        parentNode: isPseudoRoot ? null : nextNode,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\n        path: selfPath\n      })\n      childIndex = mapResult.treeIndex\n\n      return mapResult.node\n    })\n  }\n\n  return {\n    node: callback(selfInfo),\n    treeIndex: childIndex\n  }\n}\n\n/**\n * Count all the visible (expanded) descendants in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n *\n * @return {number} count\n */\nexport function getVisibleNodeCount({ treeData }) {\n  const traverse = (node) => {\n    if (\n      !node.children ||\n      node.expanded !== true ||\n      typeof node.children === 'function'\n    ) {\n      return 1\n    }\n\n    return (\n      1 +\n      node.children.reduce(\n        (total, currentNode) => total + traverse(currentNode),\n        0\n      )\n    )\n  }\n\n  return treeData.reduce(\n    (total, currentNode) => total + traverse(currentNode),\n    0\n  )\n}\n\n/**\n * Get the <targetIndex>th visible node in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} targetIndex - The index of the node to search for\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }|null} node - The node at targetIndex, or null if not found\n */\nexport function getVisibleNodeInfoAtIndex({\n  treeData,\n  index: targetIndex,\n  getNodeKey\n}) {\n  if (!treeData || treeData.length < 1) {\n    return null\n  }\n\n  // Call the tree traversal with a pseudo-root node\n  const result = getNodeDataAtTreeIndexOrNextIndex({\n    targetIndex,\n    getNodeKey,\n    node: {\n      children: treeData,\n      expanded: true\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: [],\n    isPseudoRoot: true\n  })\n\n  if (result.node) {\n    return result\n  }\n\n  return null\n}\n\n/**\n * Walk descendants depth-first and call a callback on each\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return void\n */\nexport function walk({\n  treeData,\n  getNodeKey,\n  callback,\n  ignoreCollapsed = true\n}) {\n  if (!treeData || treeData.length < 1) {\n    return\n  }\n\n  walkDescendants({\n    callback,\n    getNodeKey,\n    ignoreCollapsed,\n    isPseudoRoot: true,\n    node: { children: treeData },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  })\n}\n\n/**\n * Perform a depth-first transversal of the descendants and\n *  make a change to every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function map({\n  treeData,\n  getNodeKey,\n  callback,\n  ignoreCollapsed = true\n}) {\n  if (!treeData || treeData.length < 1) {\n    return []\n  }\n\n  return mapDescendants({\n    callback,\n    getNodeKey,\n    ignoreCollapsed,\n    isPseudoRoot: true,\n    node: { children: treeData },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  }).node.children\n}\n\n/**\n * Expand or close every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {?boolean} expanded - Whether the node is expanded or not\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function toggleExpandedForAll({ treeData, expanded = true }) {\n  return map({\n    treeData,\n    callback: ({ node }) => ({ ...node, expanded }),\n    getNodeKey: ({ treeIndex }) => treeIndex,\n    ignoreCollapsed: false\n  })\n}\n\n/**\n * Replaces node at path with object, or callback-defined object\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be changed\n * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function changeNodeAtPath({\n  treeData,\n  path,\n  newNode,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  const RESULT_MISS = 'RESULT_MISS'\n  const traverse = ({\n    isPseudoRoot = false,\n    node,\n    currentTreeIndex,\n    pathIndex\n  }) => {\n    if (\n      !isPseudoRoot &&\n      getNodeKey({ node, treeIndex: currentTreeIndex }) !== path[pathIndex]\n    ) {\n      return RESULT_MISS\n    }\n\n    if (pathIndex >= path.length - 1) {\n      // If this is the final location in the path, return its changed form\n      return typeof newNode === 'function'\n        ? newNode({ node, treeIndex: currentTreeIndex })\n        : newNode\n    }\n    if (!node.children) {\n      // If this node is part of the path, but has no children, return the unchanged node\n      throw new Error('Path referenced children of node with no children.')\n    }\n\n    let nextTreeIndex = currentTreeIndex + 1\n    for (let i = 0; i < node.children.length; i += 1) {\n      const result = traverse({\n        node: node.children[i],\n        currentTreeIndex: nextTreeIndex,\n        pathIndex: pathIndex + 1\n      })\n\n      // If the result went down the correct path\n      if (result !== RESULT_MISS) {\n        if (result) {\n          // If the result was truthy (in this case, an object),\n          //  pass it to the next level of recursion up\n          return {\n            ...node,\n            children: [\n              ...node.children.slice(0, i),\n              result,\n              ...node.children.slice(i + 1)\n            ]\n          }\n        }\n        // If the result was falsy (returned from the newNode function), then\n        //  delete the node from the array.\n        return {\n          ...node,\n          children: [\n            ...node.children.slice(0, i),\n            ...node.children.slice(i + 1)\n          ]\n        }\n      }\n\n      nextTreeIndex +=\n        1 + getDescendantCount({ node: node.children[i], ignoreCollapsed })\n    }\n\n    return RESULT_MISS\n  }\n\n  // Use a pseudo-root node in the beginning traversal\n  const result = traverse({\n    node: { children: treeData },\n    currentTreeIndex: -1,\n    pathIndex: -1,\n    isPseudoRoot: true\n  })\n\n  if (result === RESULT_MISS) {\n    throw new Error('No node found at the given path.')\n  }\n\n  return result.children\n}\n\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The tree data with the node removed\n */\nexport function removeNodeAtPath({\n  treeData,\n  path,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  return changeNodeAtPath({\n    treeData,\n    path,\n    getNodeKey,\n    ignoreCollapsed,\n    newNode: null // Delete the node\n  })\n}\n\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node removed\n * @return {Object} result.node - The node that was removed\n * @return {number} result.treeIndex - The previous treeIndex of the removed node\n */\nexport function removeNode({\n  treeData,\n  path,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  let removedNode = null\n  let removedTreeIndex = null\n  const nextTreeData = changeNodeAtPath({\n    treeData,\n    path,\n    getNodeKey,\n    ignoreCollapsed,\n    newNode: ({ node, treeIndex }) => {\n      // Store the target node and delete it from the tree\n      removedNode = node\n      removedTreeIndex = treeIndex\n\n      return null\n    }\n  })\n\n  return {\n    treeData: nextTreeData,\n    node: removedNode,\n    treeIndex: removedTreeIndex\n  }\n}\n\n/**\n * Gets the node at the specified path\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\n */\nexport function getNodeAtPath({\n  treeData,\n  path,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  let foundNodeInfo = null\n\n  try {\n    changeNodeAtPath({\n      treeData,\n      path,\n      getNodeKey,\n      ignoreCollapsed,\n      newNode: ({ node, treeIndex }) => {\n        foundNodeInfo = { node, treeIndex }\n        return node\n      }\n    })\n  } catch (err) {\n    // Ignore the error -- the null return will be explanation enough\n  }\n\n  return foundNodeInfo\n}\n\n/**\n * Adds the node to the specified parent and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {!Object} newNode - The node to insert\n * @param {number|string} parentKey - The key of the to-be parentNode of the node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\n * @param {boolean=} addAsFirstChild - If true, adds new node as first child of tree\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The updated tree data\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n */\nexport function addNodeUnderParent({\n  treeData,\n  newNode,\n  parentKey = null,\n  getNodeKey,\n  ignoreCollapsed = true,\n  expandParent = false,\n  addAsFirstChild = false\n}) {\n  if (parentKey === null) {\n    return addAsFirstChild\n      ? {\n          treeData: [newNode, ...(treeData || [])],\n          treeIndex: 0\n        }\n      : {\n          treeData: [...(treeData || []), newNode],\n          treeIndex: (treeData || []).length\n        }\n  }\n\n  let insertedTreeIndex = null\n  let hasBeenAdded = false\n  const changedTreeData = map({\n    treeData,\n    getNodeKey,\n    ignoreCollapsed,\n    callback: ({ node, treeIndex, path }) => {\n      const key = path ? path[path.length - 1] : null\n      // Return nodes that are not the parent as-is\n      if (hasBeenAdded || key !== parentKey) {\n        return node\n      }\n      hasBeenAdded = true\n\n      const parentNode = {\n        ...node\n      }\n\n      if (expandParent) {\n        parentNode.expanded = true\n      }\n\n      // If no children exist yet, just add the single newNode\n      if (!parentNode.children) {\n        insertedTreeIndex = treeIndex + 1\n        return {\n          ...parentNode,\n          children: [newNode]\n        }\n      }\n\n      if (typeof parentNode.children === 'function') {\n        throw new Error('Cannot add to children defined by a function')\n      }\n\n      let nextTreeIndex = treeIndex + 1\n      for (let i = 0; i < parentNode.children.length; i += 1) {\n        nextTreeIndex +=\n          1 +\n          getDescendantCount({ node: parentNode.children[i], ignoreCollapsed })\n      }\n\n      insertedTreeIndex = nextTreeIndex\n\n      const children = addAsFirstChild\n        ? [newNode, ...parentNode.children]\n        : [...parentNode.children, newNode]\n\n      return {\n        ...parentNode,\n        children\n      }\n    }\n  })\n\n  if (!hasBeenAdded) {\n    throw new Error('No node found with the given key.')\n  }\n\n  return {\n    treeData: changedTreeData,\n    treeIndex: insertedTreeIndex\n  }\n}\n\nfunction addNodeAtDepthAndIndex({\n  targetDepth,\n  minimumTreeIndex,\n  newNode,\n  ignoreCollapsed,\n  expandParent,\n  isPseudoRoot = false,\n  isLastChild,\n  node,\n  currentIndex,\n  currentDepth,\n  getNodeKey,\n  path = []\n}) {\n  const selfPath = (n) =>\n    isPseudoRoot\n      ? []\n      : [...path, getNodeKey({ node: n, treeIndex: currentIndex })]\n\n  // If the current position is the only possible place to add, add it\n  if (\n    currentIndex >= minimumTreeIndex - 1 ||\n    (isLastChild && !(node.children && node.children.length))\n  ) {\n    if (typeof node.children === 'function') {\n      throw new Error('Cannot add to children defined by a function')\n    } else {\n      const extraNodeProps = expandParent ? { expanded: true } : {}\n      const nextNode = {\n        ...node,\n\n        ...extraNodeProps,\n        children: node.children ? [newNode, ...node.children] : [newNode]\n      }\n\n      return {\n        node: nextNode,\n        nextIndex: currentIndex + 2,\n        insertedTreeIndex: currentIndex + 1,\n        parentPath: selfPath(nextNode),\n        parentNode: isPseudoRoot ? null : nextNode\n      }\n    }\n  }\n\n  // If this is the target depth for the insertion,\n  // i.e., where the newNode can be added to the current node's children\n  if (currentDepth >= targetDepth - 1) {\n    // Skip over nodes with no children or hidden children\n    if (\n      !node.children ||\n      typeof node.children === 'function' ||\n      (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n    ) {\n      return { node, nextIndex: currentIndex + 1 }\n    }\n\n    // Scan over the children to see if there's a place among them that fulfills\n    // the minimumTreeIndex requirement\n    let childIndex = currentIndex + 1\n    let insertedTreeIndex = null\n    let insertIndex = null\n    for (let i = 0; i < node.children.length; i += 1) {\n      // If a valid location is found, mark it as the insertion location and\n      // break out of the loop\n      if (childIndex >= minimumTreeIndex) {\n        insertedTreeIndex = childIndex\n        insertIndex = i\n        break\n      }\n\n      // Increment the index by the child itself plus the number of descendants it has\n      childIndex +=\n        1 + getDescendantCount({ node: node.children[i], ignoreCollapsed })\n    }\n\n    // If no valid indices to add the node were found\n    if (insertIndex === null) {\n      // If the last position in this node's children is less than the minimum index\n      // and there are more children on the level of this node, return without insertion\n      if (childIndex < minimumTreeIndex && !isLastChild) {\n        return { node, nextIndex: childIndex }\n      }\n\n      // Use the last position in the children array to insert the newNode\n      insertedTreeIndex = childIndex\n      insertIndex = node.children.length\n    }\n\n    // Insert the newNode at the insertIndex\n    const nextNode = {\n      ...node,\n      children: [\n        ...node.children.slice(0, insertIndex),\n        newNode,\n        ...node.children.slice(insertIndex)\n      ]\n    }\n\n    // Return node with successful insert result\n    return {\n      node: nextNode,\n      nextIndex: childIndex,\n      insertedTreeIndex,\n      parentPath: selfPath(nextNode),\n      parentNode: isPseudoRoot ? null : nextNode\n    }\n  }\n\n  // Skip over nodes with no children or hidden children\n  if (\n    !node.children ||\n    typeof node.children === 'function' ||\n    (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n  ) {\n    return { node, nextIndex: currentIndex + 1 }\n  }\n\n  // Get all descendants\n  let insertedTreeIndex = null\n  let pathFragment = null\n  let parentNode = null\n  let childIndex = currentIndex + 1\n  let newChildren = node.children\n  if (typeof newChildren !== 'function') {\n    newChildren = newChildren.map((child, i) => {\n      if (insertedTreeIndex !== null) {\n        return child\n      }\n\n      const mapResult = addNodeAtDepthAndIndex({\n        targetDepth,\n        minimumTreeIndex,\n        newNode,\n        ignoreCollapsed,\n        expandParent,\n        isLastChild: isLastChild && i === newChildren.length - 1,\n        node: child,\n        currentIndex: childIndex,\n        currentDepth: currentDepth + 1,\n        getNodeKey,\n        path: [] // Cannot determine the parent path until the children have been processed\n      })\n\n      if ('insertedTreeIndex' in mapResult) {\n        ;({\n          insertedTreeIndex,\n          parentNode,\n          parentPath: pathFragment\n        } = mapResult)\n      }\n\n      childIndex = mapResult.nextIndex\n\n      return mapResult.node\n    })\n  }\n\n  const nextNode = { ...node, children: newChildren }\n  const result = {\n    node: nextNode,\n    nextIndex: childIndex\n  }\n\n  if (insertedTreeIndex !== null) {\n    result.insertedTreeIndex = insertedTreeIndex\n    result.parentPath = [...selfPath(nextNode), ...pathFragment]\n    result.parentNode = parentNode\n  }\n\n  return result\n}\n\n/**\n * Insert a node into the tree at the given depth, after the minimum index\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} depth - The depth to insert the node at (the first level of the array being depth 0)\n * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\n * @param {!Object} newNode - The node to insert into the tree\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parent of the inserted node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node added\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\n * @return {Object} result.parentNode - The parent node of the inserted node\n */\nexport function insertNode({\n  treeData,\n  depth: targetDepth,\n  minimumTreeIndex,\n  newNode,\n  getNodeKey = () => {},\n  ignoreCollapsed = true,\n  expandParent = false\n}) {\n  if (!treeData && targetDepth === 0) {\n    return {\n      treeData: [newNode],\n      treeIndex: 0,\n      path: [getNodeKey({ node: newNode, treeIndex: 0 })],\n      parentNode: null\n    }\n  }\n\n  const insertResult = addNodeAtDepthAndIndex({\n    targetDepth,\n    minimumTreeIndex,\n    newNode,\n    ignoreCollapsed,\n    expandParent,\n    getNodeKey,\n    isPseudoRoot: true,\n    isLastChild: true,\n    node: { children: treeData },\n    currentIndex: -1,\n    currentDepth: -1\n  })\n\n  if (!('insertedTreeIndex' in insertResult)) {\n    throw new Error('No suitable position found to insert.')\n  }\n\n  const treeIndex = insertResult.insertedTreeIndex\n  return {\n    treeData: insertResult.node.children,\n    treeIndex,\n    path: [\n      ...insertResult.parentPath,\n      getNodeKey({ node: newNode, treeIndex })\n    ],\n    parentNode: insertResult.parentNode\n  }\n}\n\n/**\n * Get tree data flattened.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }}[] nodes - The node array\n */\nexport function getFlatDataFromTree({\n  treeData,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  if (!treeData || treeData.length < 1) {\n    return []\n  }\n\n  const flattened = []\n  walk({\n    treeData,\n    getNodeKey,\n    ignoreCollapsed,\n    callback: (nodeInfo) => {\n      flattened.push(nodeInfo)\n    }\n  })\n\n  return flattened\n}\n\n/**\n * Generate a tree structure from flat data.\n *\n * @param {!Object[]} flatData\n * @param {!function=} getKey - Function to get the key from the nodeData\n * @param {!function=} getParentKey - Function to get the parent key from the nodeData\n * @param {string|number=} rootKey - The value returned by `getParentKey` that corresponds to the root node.\n *                                  For example, if your nodes have id 1-99, you might use rootKey = 0\n *\n * @return {Object[]} treeData - The flat data represented as a tree\n */\nexport function getTreeFromFlatData({\n  flatData,\n  getKey = (node) => node.id,\n  getParentKey = (node) => node.parentId,\n  rootKey = '0'\n}) {\n  if (!flatData) {\n    return []\n  }\n\n  const childrenToParents = {}\n  flatData.forEach((child) => {\n    const parentKey = getParentKey(child)\n\n    if (parentKey in childrenToParents) {\n      childrenToParents[parentKey].push(child)\n    } else {\n      childrenToParents[parentKey] = [child]\n    }\n  })\n\n  if (!(rootKey in childrenToParents)) {\n    return []\n  }\n\n  const trav = (parent) => {\n    const parentKey = getKey(parent)\n    if (parentKey in childrenToParents) {\n      return {\n        ...parent,\n        children: childrenToParents[parentKey].map((child) => trav(child))\n      }\n    }\n\n    return { ...parent }\n  }\n\n  return childrenToParents[rootKey].map((child) => trav(child))\n}\n\n/**\n * Check if a node is a descendant of another node.\n *\n * @param {!Object} older - Potential ancestor of younger node\n * @param {!Object} younger - Potential descendant of older node\n *\n * @return {boolean}\n */\nexport function isDescendant(older, younger) {\n  return (\n    !!older.children &&\n    typeof older.children !== 'function' &&\n    older.children.some(\n      (child) => child === younger || isDescendant(child, younger)\n    )\n  )\n}\n\n/**\n * Get the maximum depth of the children (the depth of the root node is 0).\n *\n * @param {!Object} node - Node in the tree\n * @param {?number} depth - The current depth\n *\n * @return {number} maxDepth - The deepest depth in the tree\n */\nexport function getDepth(node, depth = 0) {\n  if (!node.children) {\n    return depth\n  }\n\n  if (typeof node.children === 'function') {\n    return depth + 1\n  }\n\n  return node.children.reduce(\n    (deepest, child) => Math.max(deepest, getDepth(child, depth + 1)),\n    depth\n  )\n}\n\n/**\n * Find nodes matching a search query in the tree,\n *\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {!Object[]} treeData - Tree data\n * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\n * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\n * @param {?number} searchFocusOffset - The offset of the match to focus on\n *                                      (e.g., 0 focuses on the first match, 1 on the second)\n * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\n * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\n *\n * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\n * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\n *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\n *                               it will be the same as the original tree data.\n */\nexport function find({\n  getNodeKey,\n  treeData,\n  searchQuery,\n  searchMethod,\n  searchFocusOffset,\n  expandAllMatchPaths = false,\n  expandFocusMatchPaths = true\n}) {\n  let matchCount = 0\n  const trav = ({ isPseudoRoot = false, node, currentIndex, path = [] }) => {\n    let matches = []\n    let isSelfMatch = false\n    let hasFocusMatch = false\n    // The pseudo-root is not considered in the path\n    const selfPath = isPseudoRoot\n      ? []\n      : [...path, getNodeKey({ node, treeIndex: currentIndex })]\n    const extraInfo = isPseudoRoot\n      ? null\n      : {\n          path: selfPath,\n          treeIndex: currentIndex\n        }\n\n    // Nodes with with children that aren't lazy\n    const hasChildren =\n      node.children &&\n      typeof node.children !== 'function' &&\n      node.children.length > 0\n\n    // Examine the current node to see if it is a match\n    if (!isPseudoRoot && searchMethod({ ...extraInfo, node, searchQuery })) {\n      if (matchCount === searchFocusOffset) {\n        hasFocusMatch = true\n      }\n\n      // Keep track of the number of matching nodes, so we know when the searchFocusOffset\n      //  is reached\n      matchCount += 1\n\n      // We cannot add this node to the matches right away, as it may be changed\n      //  during the search of the descendants. The entire node is used in\n      //  comparisons between nodes inside the `matches` and `treeData` results\n      //  of this method (`find`)\n      isSelfMatch = true\n    }\n\n    let childIndex = currentIndex\n    const newNode = { ...node }\n    if (hasChildren) {\n      // Get all descendants\n      newNode.children = newNode.children.map((child) => {\n        const mapResult = trav({\n          node: child,\n          currentIndex: childIndex + 1,\n          path: selfPath\n        })\n\n        // Ignore hidden nodes by only advancing the index counter to the returned treeIndex\n        // if the child is expanded.\n        //\n        // The child could have been expanded from the start,\n        // or expanded due to a matching node being found in its descendants\n        if (mapResult.node.expanded) {\n          childIndex = mapResult.treeIndex\n        } else {\n          childIndex += 1\n        }\n\n        if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {\n          matches = [...matches, ...mapResult.matches]\n          if (mapResult.hasFocusMatch) {\n            hasFocusMatch = true\n          }\n\n          // Expand the current node if it has descendants matching the search\n          // and the settings are set to do so.\n          if (\n            (expandAllMatchPaths && mapResult.matches.length > 0) ||\n            ((expandAllMatchPaths || expandFocusMatchPaths) &&\n              mapResult.hasFocusMatch)\n          ) {\n            newNode.expanded = true\n          }\n        }\n\n        return mapResult.node\n      })\n    }\n\n    // Cannot assign a treeIndex to hidden nodes\n    if (!isPseudoRoot && !newNode.expanded) {\n      matches = matches.map((match) => ({\n        ...match,\n        treeIndex: null\n      }))\n    }\n\n    // Add this node to the matches if it fits the search criteria.\n    // This is performed at the last minute so newNode can be sent in its final form.\n    if (isSelfMatch) {\n      matches = [{ ...extraInfo, node: newNode }, ...matches]\n    }\n\n    return {\n      node: matches.length > 0 ? newNode : node,\n      matches,\n      hasFocusMatch,\n      treeIndex: childIndex\n    }\n  }\n\n  const result = trav({\n    node: { children: treeData },\n    isPseudoRoot: true,\n    currentIndex: -1\n  })\n\n  return {\n    matches: result.matches,\n    treeData: result.node.children\n  }\n}\n"],"names":["getNodeDataAtTreeIndexOrNextIndex","_ref","targetIndex","node","currentIndex","getNodeKey","_ref$path","path","_ref$lowerSiblingCoun","lowerSiblingCounts","_ref$ignoreCollapsed","ignoreCollapsed","_ref$isPseudoRoot","isPseudoRoot","selfPath","concat","_toConsumableArray","treeIndex","children","expanded","nextIndex","childIndex","childCount","length","i","result","getDescendantCount","_ref2","_ref2$ignoreCollapsed","walkDescendants","_ref3","callback","_ref3$isPseudoRoot","_ref3$parentNode","parentNode","_ref3$path","_ref3$lowerSiblingCou","mapDescendants","_ref4","_ref4$isPseudoRoot","_ref4$parentNode","_ref4$path","_ref4$lowerSiblingCou","nextNode","_objectSpread","selfInfo","map","child","mapResult","getVisibleNodeCount","_ref5","treeData","traverse","reduce","total","currentNode","getVisibleNodeInfoAtIndex","_ref6","index","walk","_ref7","_ref7$ignoreCollapsed","_ref8","_ref8$ignoreCollapsed","toggleExpandedForAll","_ref9","_ref9$expanded","_ref10","_ref11","changeNodeAtPath","_ref12","newNode","_ref12$ignoreCollapse","RESULT_MISS","_ref13","_ref13$isPseudoRoot","currentTreeIndex","pathIndex","Error","nextTreeIndex","slice","removeNodeAtPath","_ref14","_ref14$ignoreCollapse","removeNode","_ref15","_ref15$ignoreCollapse","removedNode","removedTreeIndex","_ref16","getNodeAtPath","_ref17","_ref17$ignoreCollapse","foundNodeInfo","_ref18","err","addNodeUnderParent","_ref19","_ref19$parentKey","parentKey","_ref19$ignoreCollapse","_ref19$expandParent","expandParent","_ref19$addAsFirstChil","addAsFirstChild","insertedTreeIndex","hasBeenAdded","changedTreeData","_ref20","key","addNodeAtDepthAndIndex","_ref21","targetDepth","minimumTreeIndex","_ref21$isPseudoRoot","isLastChild","currentDepth","_ref21$path","n","extraNodeProps","parentPath","insertIndex","pathFragment","newChildren","insertNode","_ref22","depth","_ref22$getNodeKey","_ref22$ignoreCollapse","_ref22$expandParent","insertResult","getFlatDataFromTree","_ref23","_ref23$ignoreCollapse","flattened","nodeInfo","push","getTreeFromFlatData","_ref24","flatData","_ref24$getKey","getKey","id","_ref24$getParentKey","getParentKey","parentId","_ref24$rootKey","rootKey","childrenToParents","forEach","trav","parent","isDescendant","older","younger","some","getDepth","arguments","undefined","deepest","Math","max","find","_ref25","searchQuery","searchMethod","searchFocusOffset","_ref25$expandAllMatch","expandAllMatchPaths","_ref25$expandFocusMat","expandFocusMatchPaths","matchCount","_ref26","_ref26$isPseudoRoot","_ref26$path","matches","isSelfMatch","hasFocusMatch","extraInfo","hasChildren","match"],"mappings":"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"}