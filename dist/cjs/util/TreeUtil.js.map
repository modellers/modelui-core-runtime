{"version":3,"file":"TreeUtil.js","sources":["../../../src/util/TreeUtil.js"],"sourcesContent":["// copied as is from\n// https://github.com/frontend-collective/react-sortable-tree/blob/master/src/utils/tree-data-utils.js\n\n/**\n * Performs a depth-first traversal over all of the node descendants,\n * incrementing currentIndex by 1 for each\n */\nfunction getNodeDataAtTreeIndexOrNextIndex({\n  targetIndex,\n  node,\n  currentIndex,\n  getNodeKey,\n  path = [],\n  lowerSiblingCounts = [],\n  ignoreCollapsed = true,\n  isPseudoRoot = false\n}) {\n  // The pseudo-root is not considered in the path\n  const selfPath = !isPseudoRoot\n    ? [...path, getNodeKey({ node, treeIndex: currentIndex })]\n    : []\n\n  // Return target node when found\n  if (currentIndex === targetIndex) {\n    return {\n      node,\n      lowerSiblingCounts,\n      path: selfPath\n    }\n  }\n\n  // Add one and continue for nodes with no children or hidden children\n  if (!node.children || (ignoreCollapsed && node.expanded !== true)) {\n    return { nextIndex: currentIndex + 1 }\n  }\n\n  // Iterate over each child and their descendants and return the\n  // target node if childIndex reaches the targetIndex\n  let childIndex = currentIndex + 1\n  const childCount = node.children.length\n  for (let i = 0; i < childCount; i += 1) {\n    const result = getNodeDataAtTreeIndexOrNextIndex({\n      ignoreCollapsed,\n      getNodeKey,\n      targetIndex,\n      node: node.children[i],\n      currentIndex: childIndex,\n      lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\n      path: selfPath\n    })\n\n    if (result.node) {\n      return result\n    }\n\n    childIndex = result.nextIndex\n  }\n\n  // If the target node is not found, return the farthest traversed index\n  return { nextIndex: childIndex }\n}\n\nexport function getDescendantCount({ node, ignoreCollapsed = true }) {\n  return (\n    getNodeDataAtTreeIndexOrNextIndex({\n      getNodeKey: () => {},\n      ignoreCollapsed,\n      node,\n      currentIndex: 0,\n      targetIndex: -1\n    }).nextIndex - 1\n  )\n}\n\n/**\n * Walk all descendants of the given node, depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\nfunction walkDescendants({\n  callback,\n  getNodeKey,\n  ignoreCollapsed,\n  isPseudoRoot = false,\n  node,\n  parentNode = null,\n  currentIndex,\n  path = [],\n  lowerSiblingCounts = []\n}) {\n  // The pseudo-root is not considered in the path\n  const selfPath = isPseudoRoot\n    ? []\n    : [...path, getNodeKey({ node, treeIndex: currentIndex })]\n  const selfInfo = isPseudoRoot\n    ? null\n    : {\n        node,\n        parentNode,\n        path: selfPath,\n        lowerSiblingCounts,\n        treeIndex: currentIndex\n      }\n\n  if (!isPseudoRoot) {\n    const callbackResult = callback(selfInfo)\n\n    // Cut walk short if the callback returned false\n    if (callbackResult === false) {\n      return false\n    }\n  }\n\n  // Return self on nodes with no children or hidden children\n  if (\n    !node.children ||\n    (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n  ) {\n    return currentIndex\n  }\n\n  // Get all descendants\n  let childIndex = currentIndex\n  const childCount = node.children.length\n  if (typeof node.children !== 'function') {\n    for (let i = 0; i < childCount; i += 1) {\n      childIndex = walkDescendants({\n        callback,\n        getNodeKey,\n        ignoreCollapsed,\n        node: node.children[i],\n        parentNode: isPseudoRoot ? null : node,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\n        path: selfPath\n      })\n\n      // Cut walk short if the callback returned false\n      if (childIndex === false) {\n        return false\n      }\n    }\n  }\n\n  return childIndex\n}\n\n/**\n * Perform a change on the given node and all its descendants, traversing the tree depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\nfunction mapDescendants({\n  callback,\n  getNodeKey,\n  ignoreCollapsed,\n  isPseudoRoot = false,\n  node,\n  parentNode = null,\n  currentIndex,\n  path = [],\n  lowerSiblingCounts = []\n}) {\n  const nextNode = { ...node }\n\n  // The pseudo-root is not considered in the path\n  const selfPath = isPseudoRoot\n    ? []\n    : [...path, getNodeKey({ node: nextNode, treeIndex: currentIndex })]\n  const selfInfo = {\n    node: nextNode,\n    parentNode,\n    path: selfPath,\n    lowerSiblingCounts,\n    treeIndex: currentIndex\n  }\n\n  // Return self on nodes with no children or hidden children\n  if (\n    !nextNode.children ||\n    (nextNode.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n  ) {\n    return {\n      treeIndex: currentIndex,\n      node: callback(selfInfo)\n    }\n  }\n\n  // Get all descendants\n  let childIndex = currentIndex\n  const childCount = nextNode.children.length\n  if (typeof nextNode.children !== 'function') {\n    nextNode.children = nextNode.children.map((child, i) => {\n      const mapResult = mapDescendants({\n        callback,\n        getNodeKey,\n        ignoreCollapsed,\n        node: child,\n        parentNode: isPseudoRoot ? null : nextNode,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\n        path: selfPath\n      })\n      childIndex = mapResult.treeIndex\n\n      return mapResult.node\n    })\n  }\n\n  return {\n    node: callback(selfInfo),\n    treeIndex: childIndex\n  }\n}\n\n/**\n * Count all the visible (expanded) descendants in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n *\n * @return {number} count\n */\nexport function getVisibleNodeCount({ treeData }) {\n  const traverse = (node) => {\n    if (\n      !node.children ||\n      node.expanded !== true ||\n      typeof node.children === 'function'\n    ) {\n      return 1\n    }\n\n    return (\n      1 +\n      node.children.reduce(\n        (total, currentNode) => total + traverse(currentNode),\n        0\n      )\n    )\n  }\n\n  return treeData.reduce(\n    (total, currentNode) => total + traverse(currentNode),\n    0\n  )\n}\n\n/**\n * Get the <targetIndex>th visible node in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} targetIndex - The index of the node to search for\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }|null} node - The node at targetIndex, or null if not found\n */\nexport function getVisibleNodeInfoAtIndex({\n  treeData,\n  index: targetIndex,\n  getNodeKey\n}) {\n  if (!treeData || treeData.length < 1) {\n    return null\n  }\n\n  // Call the tree traversal with a pseudo-root node\n  const result = getNodeDataAtTreeIndexOrNextIndex({\n    targetIndex,\n    getNodeKey,\n    node: {\n      children: treeData,\n      expanded: true\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: [],\n    isPseudoRoot: true\n  })\n\n  if (result.node) {\n    return result\n  }\n\n  return null\n}\n\n/**\n * Walk descendants depth-first and call a callback on each\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return void\n */\nexport function walk({\n  treeData,\n  getNodeKey,\n  callback,\n  ignoreCollapsed = true\n}) {\n  if (!treeData || treeData.length < 1) {\n    return\n  }\n\n  walkDescendants({\n    callback,\n    getNodeKey,\n    ignoreCollapsed,\n    isPseudoRoot: true,\n    node: { children: treeData },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  })\n}\n\n/**\n * Perform a depth-first transversal of the descendants and\n *  make a change to every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function map({\n  treeData,\n  getNodeKey,\n  callback,\n  ignoreCollapsed = true\n}) {\n  if (!treeData || treeData.length < 1) {\n    return []\n  }\n\n  return mapDescendants({\n    callback,\n    getNodeKey,\n    ignoreCollapsed,\n    isPseudoRoot: true,\n    node: { children: treeData },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  }).node.children\n}\n\n/**\n * Expand or close every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {?boolean} expanded - Whether the node is expanded or not\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function toggleExpandedForAll({ treeData, expanded = true }) {\n  return map({\n    treeData,\n    callback: ({ node }) => ({ ...node, expanded }),\n    getNodeKey: ({ treeIndex }) => treeIndex,\n    ignoreCollapsed: false\n  })\n}\n\n/**\n * Replaces node at path with object, or callback-defined object\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be changed\n * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function changeNodeAtPath({\n  treeData,\n  path,\n  newNode,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  const RESULT_MISS = 'RESULT_MISS'\n  const traverse = ({\n    isPseudoRoot = false,\n    node,\n    currentTreeIndex,\n    pathIndex\n  }) => {\n    if (\n      !isPseudoRoot &&\n      getNodeKey({ node, treeIndex: currentTreeIndex }) !== path[pathIndex]\n    ) {\n      return RESULT_MISS\n    }\n\n    if (pathIndex >= path.length - 1) {\n      // If this is the final location in the path, return its changed form\n      return typeof newNode === 'function'\n        ? newNode({ node, treeIndex: currentTreeIndex })\n        : newNode\n    }\n    if (!node.children) {\n      // If this node is part of the path, but has no children, return the unchanged node\n      throw new Error('Path referenced children of node with no children.')\n    }\n\n    let nextTreeIndex = currentTreeIndex + 1\n    for (let i = 0; i < node.children.length; i += 1) {\n      const result = traverse({\n        node: node.children[i],\n        currentTreeIndex: nextTreeIndex,\n        pathIndex: pathIndex + 1\n      })\n\n      // If the result went down the correct path\n      if (result !== RESULT_MISS) {\n        if (result) {\n          // If the result was truthy (in this case, an object),\n          //  pass it to the next level of recursion up\n          return {\n            ...node,\n            children: [\n              ...node.children.slice(0, i),\n              result,\n              ...node.children.slice(i + 1)\n            ]\n          }\n        }\n        // If the result was falsy (returned from the newNode function), then\n        //  delete the node from the array.\n        return {\n          ...node,\n          children: [\n            ...node.children.slice(0, i),\n            ...node.children.slice(i + 1)\n          ]\n        }\n      }\n\n      nextTreeIndex +=\n        1 + getDescendantCount({ node: node.children[i], ignoreCollapsed })\n    }\n\n    return RESULT_MISS\n  }\n\n  // Use a pseudo-root node in the beginning traversal\n  const result = traverse({\n    node: { children: treeData },\n    currentTreeIndex: -1,\n    pathIndex: -1,\n    isPseudoRoot: true\n  })\n\n  if (result === RESULT_MISS) {\n    throw new Error('No node found at the given path.')\n  }\n\n  return result.children\n}\n\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The tree data with the node removed\n */\nexport function removeNodeAtPath({\n  treeData,\n  path,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  return changeNodeAtPath({\n    treeData,\n    path,\n    getNodeKey,\n    ignoreCollapsed,\n    newNode: null // Delete the node\n  })\n}\n\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node removed\n * @return {Object} result.node - The node that was removed\n * @return {number} result.treeIndex - The previous treeIndex of the removed node\n */\nexport function removeNode({\n  treeData,\n  path,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  let removedNode = null\n  let removedTreeIndex = null\n  const nextTreeData = changeNodeAtPath({\n    treeData,\n    path,\n    getNodeKey,\n    ignoreCollapsed,\n    newNode: ({ node, treeIndex }) => {\n      // Store the target node and delete it from the tree\n      removedNode = node\n      removedTreeIndex = treeIndex\n\n      return null\n    }\n  })\n\n  return {\n    treeData: nextTreeData,\n    node: removedNode,\n    treeIndex: removedTreeIndex\n  }\n}\n\n/**\n * Gets the node at the specified path\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\n */\nexport function getNodeAtPath({\n  treeData,\n  path,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  let foundNodeInfo = null\n\n  try {\n    changeNodeAtPath({\n      treeData,\n      path,\n      getNodeKey,\n      ignoreCollapsed,\n      newNode: ({ node, treeIndex }) => {\n        foundNodeInfo = { node, treeIndex }\n        return node\n      }\n    })\n  } catch (err) {\n    // Ignore the error -- the null return will be explanation enough\n  }\n\n  return foundNodeInfo\n}\n\n/**\n * Adds the node to the specified parent and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {!Object} newNode - The node to insert\n * @param {number|string} parentKey - The key of the to-be parentNode of the node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\n * @param {boolean=} addAsFirstChild - If true, adds new node as first child of tree\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The updated tree data\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n */\nexport function addNodeUnderParent({\n  treeData,\n  newNode,\n  parentKey = null,\n  getNodeKey,\n  ignoreCollapsed = true,\n  expandParent = false,\n  addAsFirstChild = false\n}) {\n  if (parentKey === null) {\n    return addAsFirstChild\n      ? {\n          treeData: [newNode, ...(treeData || [])],\n          treeIndex: 0\n        }\n      : {\n          treeData: [...(treeData || []), newNode],\n          treeIndex: (treeData || []).length\n        }\n  }\n\n  let insertedTreeIndex = null\n  let hasBeenAdded = false\n  const changedTreeData = map({\n    treeData,\n    getNodeKey,\n    ignoreCollapsed,\n    callback: ({ node, treeIndex, path }) => {\n      const key = path ? path[path.length - 1] : null\n      // Return nodes that are not the parent as-is\n      if (hasBeenAdded || key !== parentKey) {\n        return node\n      }\n      hasBeenAdded = true\n\n      const parentNode = {\n        ...node\n      }\n\n      if (expandParent) {\n        parentNode.expanded = true\n      }\n\n      // If no children exist yet, just add the single newNode\n      if (!parentNode.children) {\n        insertedTreeIndex = treeIndex + 1\n        return {\n          ...parentNode,\n          children: [newNode]\n        }\n      }\n\n      if (typeof parentNode.children === 'function') {\n        throw new Error('Cannot add to children defined by a function')\n      }\n\n      let nextTreeIndex = treeIndex + 1\n      for (let i = 0; i < parentNode.children.length; i += 1) {\n        nextTreeIndex +=\n          1 +\n          getDescendantCount({ node: parentNode.children[i], ignoreCollapsed })\n      }\n\n      insertedTreeIndex = nextTreeIndex\n\n      const children = addAsFirstChild\n        ? [newNode, ...parentNode.children]\n        : [...parentNode.children, newNode]\n\n      return {\n        ...parentNode,\n        children\n      }\n    }\n  })\n\n  if (!hasBeenAdded) {\n    throw new Error('No node found with the given key.')\n  }\n\n  return {\n    treeData: changedTreeData,\n    treeIndex: insertedTreeIndex\n  }\n}\n\nfunction addNodeAtDepthAndIndex({\n  targetDepth,\n  minimumTreeIndex,\n  newNode,\n  ignoreCollapsed,\n  expandParent,\n  isPseudoRoot = false,\n  isLastChild,\n  node,\n  currentIndex,\n  currentDepth,\n  getNodeKey,\n  path = []\n}) {\n  const selfPath = (n) =>\n    isPseudoRoot\n      ? []\n      : [...path, getNodeKey({ node: n, treeIndex: currentIndex })]\n\n  // If the current position is the only possible place to add, add it\n  if (\n    currentIndex >= minimumTreeIndex - 1 ||\n    (isLastChild && !(node.children && node.children.length))\n  ) {\n    if (typeof node.children === 'function') {\n      throw new Error('Cannot add to children defined by a function')\n    } else {\n      const extraNodeProps = expandParent ? { expanded: true } : {}\n      const nextNode = {\n        ...node,\n\n        ...extraNodeProps,\n        children: node.children ? [newNode, ...node.children] : [newNode]\n      }\n\n      return {\n        node: nextNode,\n        nextIndex: currentIndex + 2,\n        insertedTreeIndex: currentIndex + 1,\n        parentPath: selfPath(nextNode),\n        parentNode: isPseudoRoot ? null : nextNode\n      }\n    }\n  }\n\n  // If this is the target depth for the insertion,\n  // i.e., where the newNode can be added to the current node's children\n  if (currentDepth >= targetDepth - 1) {\n    // Skip over nodes with no children or hidden children\n    if (\n      !node.children ||\n      typeof node.children === 'function' ||\n      (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n    ) {\n      return { node, nextIndex: currentIndex + 1 }\n    }\n\n    // Scan over the children to see if there's a place among them that fulfills\n    // the minimumTreeIndex requirement\n    let childIndex = currentIndex + 1\n    let insertedTreeIndex = null\n    let insertIndex = null\n    for (let i = 0; i < node.children.length; i += 1) {\n      // If a valid location is found, mark it as the insertion location and\n      // break out of the loop\n      if (childIndex >= minimumTreeIndex) {\n        insertedTreeIndex = childIndex\n        insertIndex = i\n        break\n      }\n\n      // Increment the index by the child itself plus the number of descendants it has\n      childIndex +=\n        1 + getDescendantCount({ node: node.children[i], ignoreCollapsed })\n    }\n\n    // If no valid indices to add the node were found\n    if (insertIndex === null) {\n      // If the last position in this node's children is less than the minimum index\n      // and there are more children on the level of this node, return without insertion\n      if (childIndex < minimumTreeIndex && !isLastChild) {\n        return { node, nextIndex: childIndex }\n      }\n\n      // Use the last position in the children array to insert the newNode\n      insertedTreeIndex = childIndex\n      insertIndex = node.children.length\n    }\n\n    // Insert the newNode at the insertIndex\n    const nextNode = {\n      ...node,\n      children: [\n        ...node.children.slice(0, insertIndex),\n        newNode,\n        ...node.children.slice(insertIndex)\n      ]\n    }\n\n    // Return node with successful insert result\n    return {\n      node: nextNode,\n      nextIndex: childIndex,\n      insertedTreeIndex,\n      parentPath: selfPath(nextNode),\n      parentNode: isPseudoRoot ? null : nextNode\n    }\n  }\n\n  // Skip over nodes with no children or hidden children\n  if (\n    !node.children ||\n    typeof node.children === 'function' ||\n    (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n  ) {\n    return { node, nextIndex: currentIndex + 1 }\n  }\n\n  // Get all descendants\n  let insertedTreeIndex = null\n  let pathFragment = null\n  let parentNode = null\n  let childIndex = currentIndex + 1\n  let newChildren = node.children\n  if (typeof newChildren !== 'function') {\n    newChildren = newChildren.map((child, i) => {\n      if (insertedTreeIndex !== null) {\n        return child\n      }\n\n      const mapResult = addNodeAtDepthAndIndex({\n        targetDepth,\n        minimumTreeIndex,\n        newNode,\n        ignoreCollapsed,\n        expandParent,\n        isLastChild: isLastChild && i === newChildren.length - 1,\n        node: child,\n        currentIndex: childIndex,\n        currentDepth: currentDepth + 1,\n        getNodeKey,\n        path: [] // Cannot determine the parent path until the children have been processed\n      })\n\n      if ('insertedTreeIndex' in mapResult) {\n        ;({\n          insertedTreeIndex,\n          parentNode,\n          parentPath: pathFragment\n        } = mapResult)\n      }\n\n      childIndex = mapResult.nextIndex\n\n      return mapResult.node\n    })\n  }\n\n  const nextNode = { ...node, children: newChildren }\n  const result = {\n    node: nextNode,\n    nextIndex: childIndex\n  }\n\n  if (insertedTreeIndex !== null) {\n    result.insertedTreeIndex = insertedTreeIndex\n    result.parentPath = [...selfPath(nextNode), ...pathFragment]\n    result.parentNode = parentNode\n  }\n\n  return result\n}\n\n/**\n * Insert a node into the tree at the given depth, after the minimum index\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} depth - The depth to insert the node at (the first level of the array being depth 0)\n * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\n * @param {!Object} newNode - The node to insert into the tree\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parent of the inserted node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node added\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\n * @return {Object} result.parentNode - The parent node of the inserted node\n */\nexport function insertNode({\n  treeData,\n  depth: targetDepth,\n  minimumTreeIndex,\n  newNode,\n  getNodeKey = () => {},\n  ignoreCollapsed = true,\n  expandParent = false\n}) {\n  if (!treeData && targetDepth === 0) {\n    return {\n      treeData: [newNode],\n      treeIndex: 0,\n      path: [getNodeKey({ node: newNode, treeIndex: 0 })],\n      parentNode: null\n    }\n  }\n\n  const insertResult = addNodeAtDepthAndIndex({\n    targetDepth,\n    minimumTreeIndex,\n    newNode,\n    ignoreCollapsed,\n    expandParent,\n    getNodeKey,\n    isPseudoRoot: true,\n    isLastChild: true,\n    node: { children: treeData },\n    currentIndex: -1,\n    currentDepth: -1\n  })\n\n  if (!('insertedTreeIndex' in insertResult)) {\n    throw new Error('No suitable position found to insert.')\n  }\n\n  const treeIndex = insertResult.insertedTreeIndex\n  return {\n    treeData: insertResult.node.children,\n    treeIndex,\n    path: [\n      ...insertResult.parentPath,\n      getNodeKey({ node: newNode, treeIndex })\n    ],\n    parentNode: insertResult.parentNode\n  }\n}\n\n/**\n * Get tree data flattened.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }}[] nodes - The node array\n */\nexport function getFlatDataFromTree({\n  treeData,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  if (!treeData || treeData.length < 1) {\n    return []\n  }\n\n  const flattened = []\n  walk({\n    treeData,\n    getNodeKey,\n    ignoreCollapsed,\n    callback: (nodeInfo) => {\n      flattened.push(nodeInfo)\n    }\n  })\n\n  return flattened\n}\n\n/**\n * Generate a tree structure from flat data.\n *\n * @param {!Object[]} flatData\n * @param {!function=} getKey - Function to get the key from the nodeData\n * @param {!function=} getParentKey - Function to get the parent key from the nodeData\n * @param {string|number=} rootKey - The value returned by `getParentKey` that corresponds to the root node.\n *                                  For example, if your nodes have id 1-99, you might use rootKey = 0\n *\n * @return {Object[]} treeData - The flat data represented as a tree\n */\nexport function getTreeFromFlatData({\n  flatData,\n  getKey = (node) => node.id,\n  getParentKey = (node) => node.parentId,\n  rootKey = '0'\n}) {\n  if (!flatData) {\n    return []\n  }\n\n  const childrenToParents = {}\n  flatData.forEach((child) => {\n    const parentKey = getParentKey(child)\n\n    if (parentKey in childrenToParents) {\n      childrenToParents[parentKey].push(child)\n    } else {\n      childrenToParents[parentKey] = [child]\n    }\n  })\n\n  if (!(rootKey in childrenToParents)) {\n    return []\n  }\n\n  const trav = (parent) => {\n    const parentKey = getKey(parent)\n    if (parentKey in childrenToParents) {\n      return {\n        ...parent,\n        children: childrenToParents[parentKey].map((child) => trav(child))\n      }\n    }\n\n    return { ...parent }\n  }\n\n  return childrenToParents[rootKey].map((child) => trav(child))\n}\n\n/**\n * Check if a node is a descendant of another node.\n *\n * @param {!Object} older - Potential ancestor of younger node\n * @param {!Object} younger - Potential descendant of older node\n *\n * @return {boolean}\n */\nexport function isDescendant(older, younger) {\n  return (\n    !!older.children &&\n    typeof older.children !== 'function' &&\n    older.children.some(\n      (child) => child === younger || isDescendant(child, younger)\n    )\n  )\n}\n\n/**\n * Get the maximum depth of the children (the depth of the root node is 0).\n *\n * @param {!Object} node - Node in the tree\n * @param {?number} depth - The current depth\n *\n * @return {number} maxDepth - The deepest depth in the tree\n */\nexport function getDepth(node, depth = 0) {\n  if (!node.children) {\n    return depth\n  }\n\n  if (typeof node.children === 'function') {\n    return depth + 1\n  }\n\n  return node.children.reduce(\n    (deepest, child) => Math.max(deepest, getDepth(child, depth + 1)),\n    depth\n  )\n}\n\n/**\n * Find nodes matching a search query in the tree,\n *\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {!Object[]} treeData - Tree data\n * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\n * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\n * @param {?number} searchFocusOffset - The offset of the match to focus on\n *                                      (e.g., 0 focuses on the first match, 1 on the second)\n * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\n * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\n *\n * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\n * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\n *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\n *                               it will be the same as the original tree data.\n */\nexport function find({\n  getNodeKey,\n  treeData,\n  searchQuery,\n  searchMethod,\n  searchFocusOffset,\n  expandAllMatchPaths = false,\n  expandFocusMatchPaths = true\n}) {\n  let matchCount = 0\n  const trav = ({ isPseudoRoot = false, node, currentIndex, path = [] }) => {\n    let matches = []\n    let isSelfMatch = false\n    let hasFocusMatch = false\n    // The pseudo-root is not considered in the path\n    const selfPath = isPseudoRoot\n      ? []\n      : [...path, getNodeKey({ node, treeIndex: currentIndex })]\n    const extraInfo = isPseudoRoot\n      ? null\n      : {\n          path: selfPath,\n          treeIndex: currentIndex\n        }\n\n    // Nodes with with children that aren't lazy\n    const hasChildren =\n      node.children &&\n      typeof node.children !== 'function' &&\n      node.children.length > 0\n\n    // Examine the current node to see if it is a match\n    if (!isPseudoRoot && searchMethod({ ...extraInfo, node, searchQuery })) {\n      if (matchCount === searchFocusOffset) {\n        hasFocusMatch = true\n      }\n\n      // Keep track of the number of matching nodes, so we know when the searchFocusOffset\n      //  is reached\n      matchCount += 1\n\n      // We cannot add this node to the matches right away, as it may be changed\n      //  during the search of the descendants. The entire node is used in\n      //  comparisons between nodes inside the `matches` and `treeData` results\n      //  of this method (`find`)\n      isSelfMatch = true\n    }\n\n    let childIndex = currentIndex\n    const newNode = { ...node }\n    if (hasChildren) {\n      // Get all descendants\n      newNode.children = newNode.children.map((child) => {\n        const mapResult = trav({\n          node: child,\n          currentIndex: childIndex + 1,\n          path: selfPath\n        })\n\n        // Ignore hidden nodes by only advancing the index counter to the returned treeIndex\n        // if the child is expanded.\n        //\n        // The child could have been expanded from the start,\n        // or expanded due to a matching node being found in its descendants\n        if (mapResult.node.expanded) {\n          childIndex = mapResult.treeIndex\n        } else {\n          childIndex += 1\n        }\n\n        if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {\n          matches = [...matches, ...mapResult.matches]\n          if (mapResult.hasFocusMatch) {\n            hasFocusMatch = true\n          }\n\n          // Expand the current node if it has descendants matching the search\n          // and the settings are set to do so.\n          if (\n            (expandAllMatchPaths && mapResult.matches.length > 0) ||\n            ((expandAllMatchPaths || expandFocusMatchPaths) &&\n              mapResult.hasFocusMatch)\n          ) {\n            newNode.expanded = true\n          }\n        }\n\n        return mapResult.node\n      })\n    }\n\n    // Cannot assign a treeIndex to hidden nodes\n    if (!isPseudoRoot && !newNode.expanded) {\n      matches = matches.map((match) => ({\n        ...match,\n        treeIndex: null\n      }))\n    }\n\n    // Add this node to the matches if it fits the search criteria.\n    // This is performed at the last minute so newNode can be sent in its final form.\n    if (isSelfMatch) {\n      matches = [{ ...extraInfo, node: newNode }, ...matches]\n    }\n\n    return {\n      node: matches.length > 0 ? newNode : node,\n      matches,\n      hasFocusMatch,\n      treeIndex: childIndex\n    }\n  }\n\n  const result = trav({\n    node: { children: treeData },\n    isPseudoRoot: true,\n    currentIndex: -1\n  })\n\n  return {\n    matches: result.matches,\n    treeData: result.node.children\n  }\n}\n"],"names":["getNodeDataAtTreeIndexOrNextIndex","_ref","targetIndex","node","currentIndex","getNodeKey","_ref$path","path","_ref$lowerSiblingCoun","lowerSiblingCounts","_ref$ignoreCollapsed","ignoreCollapsed","_ref$isPseudoRoot","isPseudoRoot","selfPath","concat","_toConsumableArray","treeIndex","children","expanded","nextIndex","childIndex","childCount","length","i","result","getDescendantCount","_ref2","_ref2$ignoreCollapsed","walkDescendants","_ref3","callback","_ref3$isPseudoRoot","_ref3$parentNode","parentNode","_ref3$path","_ref3$lowerSiblingCou","mapDescendants","_ref4","_ref4$isPseudoRoot","_ref4$parentNode","_ref4$path","_ref4$lowerSiblingCou","nextNode","_objectSpread","selfInfo","map","child","mapResult","walk","_ref7","treeData","_ref7$ignoreCollapsed","_ref8","_ref8$ignoreCollapsed","changeNodeAtPath","_ref12","newNode","_ref12$ignoreCollapse","RESULT_MISS","traverse","_ref13","_ref13$isPseudoRoot","currentTreeIndex","pathIndex","Error","nextTreeIndex","_objectSpread2","slice","addNodeAtDepthAndIndex","_ref21","targetDepth","minimumTreeIndex","expandParent","_ref21$isPseudoRoot","isLastChild","currentDepth","_ref21$path","n","extraNodeProps","insertedTreeIndex","parentPath","insertIndex","pathFragment","newChildren","_ref19","_ref19$parentKey","parentKey","_ref19$ignoreCollapse","_ref19$expandParent","_ref19$addAsFirstChil","addAsFirstChild","hasBeenAdded","changedTreeData","_ref20","key","_ref25","searchQuery","searchMethod","searchFocusOffset","_ref25$expandAllMatch","expandAllMatchPaths","_ref25$expandFocusMat","expandFocusMatchPaths","matchCount","trav","_ref26","_ref26$isPseudoRoot","_ref26$path","matches","isSelfMatch","hasFocusMatch","extraInfo","hasChildren","match","getDepth","depth","arguments","undefined","reduce","deepest","Math","max","_ref23","_ref23$ignoreCollapse","flattened","nodeInfo","push","_ref17","_ref17$ignoreCollapse","foundNodeInfo","_ref18","err","_ref24","flatData","_ref24$getKey","getKey","id","_ref24$getParentKey","getParentKey","parentId","_ref24$rootKey","rootKey","childrenToParents","forEach","parent","_ref5","total","currentNode","_ref6","index","_ref22","_ref22$getNodeKey","_ref22$ignoreCollapse","_ref22$expandParent","insertResult","isDescendant","older","younger","some","_ref15","_ref15$ignoreCollapse","removedNode","removedTreeIndex","_ref16","_ref14","_ref14$ignoreCollapse","_ref9","_ref9$expanded","_ref10","_ref11"],"mappings":"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"}