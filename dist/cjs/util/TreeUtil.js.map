{"version":3,"file":"TreeUtil.js","sources":["../../../src/util/TreeUtil.js"],"sourcesContent":["// copied as is from\n// https://github.com/frontend-collective/react-sortable-tree/blob/master/src/utils/tree-data-utils.js\n\n/**\n * Performs a depth-first traversal over all of the node descendants,\n * incrementing currentIndex by 1 for each\n */\nfunction getNodeDataAtTreeIndexOrNextIndex({\n  targetIndex,\n  node,\n  currentIndex,\n  getNodeKey,\n  path = [],\n  lowerSiblingCounts = [],\n  ignoreCollapsed = true,\n  isPseudoRoot = false\n}) {\n  // The pseudo-root is not considered in the path\n  const selfPath = !isPseudoRoot\n    ? [...path, getNodeKey({ node, treeIndex: currentIndex })]\n    : []\n\n  // Return target node when found\n  if (currentIndex === targetIndex) {\n    return {\n      node,\n      lowerSiblingCounts,\n      path: selfPath\n    }\n  }\n\n  // Add one and continue for nodes with no children or hidden children\n  if (!node.children || (ignoreCollapsed && node.expanded !== true)) {\n    return { nextIndex: currentIndex + 1 }\n  }\n\n  // Iterate over each child and their descendants and return the\n  // target node if childIndex reaches the targetIndex\n  let childIndex = currentIndex + 1\n  const childCount = node.children.length\n  for (let i = 0; i < childCount; i += 1) {\n    const result = getNodeDataAtTreeIndexOrNextIndex({\n      ignoreCollapsed,\n      getNodeKey,\n      targetIndex,\n      node: node.children[i],\n      currentIndex: childIndex,\n      lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\n      path: selfPath\n    })\n\n    if (result.node) {\n      return result\n    }\n\n    childIndex = result.nextIndex\n  }\n\n  // If the target node is not found, return the farthest traversed index\n  return { nextIndex: childIndex }\n}\n\nexport function getDescendantCount({ node, ignoreCollapsed = true }) {\n  return (\n    getNodeDataAtTreeIndexOrNextIndex({\n      getNodeKey: () => {},\n      ignoreCollapsed,\n      node,\n      currentIndex: 0,\n      targetIndex: -1\n    }).nextIndex - 1\n  )\n}\n\n/**\n * Walk all descendants of the given node, depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\nfunction walkDescendants({\n  callback,\n  getNodeKey,\n  ignoreCollapsed,\n  isPseudoRoot = false,\n  node,\n  parentNode = null,\n  currentIndex,\n  path = [],\n  lowerSiblingCounts = []\n}) {\n  // The pseudo-root is not considered in the path\n  const selfPath = isPseudoRoot\n    ? []\n    : [...path, getNodeKey({ node, treeIndex: currentIndex })]\n  const selfInfo = isPseudoRoot\n    ? null\n    : {\n        node,\n        parentNode,\n        path: selfPath,\n        lowerSiblingCounts,\n        treeIndex: currentIndex\n      }\n\n  if (!isPseudoRoot) {\n    const callbackResult = callback(selfInfo)\n\n    // Cut walk short if the callback returned false\n    if (callbackResult === false) {\n      return false\n    }\n  }\n\n  // Return self on nodes with no children or hidden children\n  if (\n    !node.children ||\n    (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n  ) {\n    return currentIndex\n  }\n\n  // Get all descendants\n  let childIndex = currentIndex\n  const childCount = node.children.length\n  if (typeof node.children !== 'function') {\n    for (let i = 0; i < childCount; i += 1) {\n      childIndex = walkDescendants({\n        callback,\n        getNodeKey,\n        ignoreCollapsed,\n        node: node.children[i],\n        parentNode: isPseudoRoot ? null : node,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\n        path: selfPath\n      })\n\n      // Cut walk short if the callback returned false\n      if (childIndex === false) {\n        return false\n      }\n    }\n  }\n\n  return childIndex\n}\n\n/**\n * Perform a change on the given node and all its descendants, traversing the tree depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\nfunction mapDescendants({\n  callback,\n  getNodeKey,\n  ignoreCollapsed,\n  isPseudoRoot = false,\n  node,\n  parentNode = null,\n  currentIndex,\n  path = [],\n  lowerSiblingCounts = []\n}) {\n  const nextNode = { ...node }\n\n  // The pseudo-root is not considered in the path\n  const selfPath = isPseudoRoot\n    ? []\n    : [...path, getNodeKey({ node: nextNode, treeIndex: currentIndex })]\n  const selfInfo = {\n    node: nextNode,\n    parentNode,\n    path: selfPath,\n    lowerSiblingCounts,\n    treeIndex: currentIndex\n  }\n\n  // Return self on nodes with no children or hidden children\n  if (\n    !nextNode.children ||\n    (nextNode.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n  ) {\n    return {\n      treeIndex: currentIndex,\n      node: callback(selfInfo)\n    }\n  }\n\n  // Get all descendants\n  let childIndex = currentIndex\n  const childCount = nextNode.children.length\n  if (typeof nextNode.children !== 'function') {\n    nextNode.children = nextNode.children.map((child, i) => {\n      const mapResult = mapDescendants({\n        callback,\n        getNodeKey,\n        ignoreCollapsed,\n        node: child,\n        parentNode: isPseudoRoot ? null : nextNode,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\n        path: selfPath\n      })\n      childIndex = mapResult.treeIndex\n\n      return mapResult.node\n    })\n  }\n\n  return {\n    node: callback(selfInfo),\n    treeIndex: childIndex\n  }\n}\n\n/**\n * Count all the visible (expanded) descendants in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n *\n * @return {number} count\n */\nexport function getVisibleNodeCount({ treeData }) {\n  const traverse = (node) => {\n    if (\n      !node.children ||\n      node.expanded !== true ||\n      typeof node.children === 'function'\n    ) {\n      return 1\n    }\n\n    return (\n      1 +\n      node.children.reduce(\n        (total, currentNode) => total + traverse(currentNode),\n        0\n      )\n    )\n  }\n\n  return treeData.reduce(\n    (total, currentNode) => total + traverse(currentNode),\n    0\n  )\n}\n\n/**\n * Get the <targetIndex>th visible node in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} targetIndex - The index of the node to search for\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }|null} node - The node at targetIndex, or null if not found\n */\nexport function getVisibleNodeInfoAtIndex({\n  treeData,\n  index: targetIndex,\n  getNodeKey\n}) {\n  if (!treeData || treeData.length < 1) {\n    return null\n  }\n\n  // Call the tree traversal with a pseudo-root node\n  const result = getNodeDataAtTreeIndexOrNextIndex({\n    targetIndex,\n    getNodeKey,\n    node: {\n      children: treeData,\n      expanded: true\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: [],\n    isPseudoRoot: true\n  })\n\n  if (result.node) {\n    return result\n  }\n\n  return null\n}\n\n/**\n * Walk descendants depth-first and call a callback on each\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return void\n */\nexport function walk({\n  treeData,\n  getNodeKey,\n  callback,\n  ignoreCollapsed = true\n}) {\n  if (!treeData || treeData.length < 1) {\n    return\n  }\n\n  walkDescendants({\n    callback,\n    getNodeKey,\n    ignoreCollapsed,\n    isPseudoRoot: true,\n    node: { children: treeData },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  })\n}\n\n/**\n * Perform a depth-first transversal of the descendants and\n *  make a change to every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function map({\n  treeData,\n  getNodeKey,\n  callback,\n  ignoreCollapsed = true\n}) {\n  if (!treeData || treeData.length < 1) {\n    return []\n  }\n\n  return mapDescendants({\n    callback,\n    getNodeKey,\n    ignoreCollapsed,\n    isPseudoRoot: true,\n    node: { children: treeData },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  }).node.children\n}\n\n/**\n * Expand or close every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {?boolean} expanded - Whether the node is expanded or not\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function toggleExpandedForAll({ treeData, expanded = true }) {\n  return map({\n    treeData,\n    callback: ({ node }) => ({ ...node, expanded }),\n    getNodeKey: ({ treeIndex }) => treeIndex,\n    ignoreCollapsed: false\n  })\n}\n\n/**\n * Replaces node at path with object, or callback-defined object\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be changed\n * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function changeNodeAtPath({\n  treeData,\n  path,\n  newNode,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  const RESULT_MISS = 'RESULT_MISS'\n  const traverse = ({\n    isPseudoRoot = false,\n    node,\n    currentTreeIndex,\n    pathIndex\n  }) => {\n    if (\n      !isPseudoRoot &&\n      getNodeKey({ node, treeIndex: currentTreeIndex }) !== path[pathIndex]\n    ) {\n      return RESULT_MISS\n    }\n\n    if (pathIndex >= path.length - 1) {\n      // If this is the final location in the path, return its changed form\n      return typeof newNode === 'function'\n        ? newNode({ node, treeIndex: currentTreeIndex })\n        : newNode\n    }\n    if (!node.children) {\n      // If this node is part of the path, but has no children, return the unchanged node\n      throw new Error('Path referenced children of node with no children.')\n    }\n\n    let nextTreeIndex = currentTreeIndex + 1\n    for (let i = 0; i < node.children.length; i += 1) {\n      const result = traverse({\n        node: node.children[i],\n        currentTreeIndex: nextTreeIndex,\n        pathIndex: pathIndex + 1\n      })\n\n      // If the result went down the correct path\n      if (result !== RESULT_MISS) {\n        if (result) {\n          // If the result was truthy (in this case, an object),\n          //  pass it to the next level of recursion up\n          return {\n            ...node,\n            children: [\n              ...node.children.slice(0, i),\n              result,\n              ...node.children.slice(i + 1)\n            ]\n          }\n        }\n        // If the result was falsy (returned from the newNode function), then\n        //  delete the node from the array.\n        return {\n          ...node,\n          children: [\n            ...node.children.slice(0, i),\n            ...node.children.slice(i + 1)\n          ]\n        }\n      }\n\n      nextTreeIndex +=\n        1 + getDescendantCount({ node: node.children[i], ignoreCollapsed })\n    }\n\n    return RESULT_MISS\n  }\n\n  // Use a pseudo-root node in the beginning traversal\n  const result = traverse({\n    node: { children: treeData },\n    currentTreeIndex: -1,\n    pathIndex: -1,\n    isPseudoRoot: true\n  })\n\n  if (result === RESULT_MISS) {\n    throw new Error('No node found at the given path.')\n  }\n\n  return result.children\n}\n\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The tree data with the node removed\n */\nexport function removeNodeAtPath({\n  treeData,\n  path,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  return changeNodeAtPath({\n    treeData,\n    path,\n    getNodeKey,\n    ignoreCollapsed,\n    newNode: null // Delete the node\n  })\n}\n\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node removed\n * @return {Object} result.node - The node that was removed\n * @return {number} result.treeIndex - The previous treeIndex of the removed node\n */\nexport function removeNode({\n  treeData,\n  path,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  let removedNode = null\n  let removedTreeIndex = null\n  const nextTreeData = changeNodeAtPath({\n    treeData,\n    path,\n    getNodeKey,\n    ignoreCollapsed,\n    newNode: ({ node, treeIndex }) => {\n      // Store the target node and delete it from the tree\n      removedNode = node\n      removedTreeIndex = treeIndex\n\n      return null\n    }\n  })\n\n  return {\n    treeData: nextTreeData,\n    node: removedNode,\n    treeIndex: removedTreeIndex\n  }\n}\n\n/**\n * Gets the node at the specified path\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\n */\nexport function getNodeAtPath({\n  treeData,\n  path,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  let foundNodeInfo = null\n\n  try {\n    changeNodeAtPath({\n      treeData,\n      path,\n      getNodeKey,\n      ignoreCollapsed,\n      newNode: ({ node, treeIndex }) => {\n        foundNodeInfo = { node, treeIndex }\n        return node\n      }\n    })\n  } catch (err) {\n    // Ignore the error -- the null return will be explanation enough\n  }\n\n  return foundNodeInfo\n}\n\n/**\n * Adds the node to the specified parent and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {!Object} newNode - The node to insert\n * @param {number|string} parentKey - The key of the to-be parentNode of the node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\n * @param {boolean=} addAsFirstChild - If true, adds new node as first child of tree\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The updated tree data\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n */\nexport function addNodeUnderParent({\n  treeData,\n  newNode,\n  parentKey = null,\n  getNodeKey,\n  ignoreCollapsed = true,\n  expandParent = false,\n  addAsFirstChild = false\n}) {\n  if (parentKey === null) {\n    return addAsFirstChild\n      ? {\n          treeData: [newNode, ...(treeData || [])],\n          treeIndex: 0\n        }\n      : {\n          treeData: [...(treeData || []), newNode],\n          treeIndex: (treeData || []).length\n        }\n  }\n\n  let insertedTreeIndex = null\n  let hasBeenAdded = false\n  const changedTreeData = map({\n    treeData,\n    getNodeKey,\n    ignoreCollapsed,\n    callback: ({ node, treeIndex, path }) => {\n      const key = path ? path[path.length - 1] : null\n      // Return nodes that are not the parent as-is\n      if (hasBeenAdded || key !== parentKey) {\n        return node\n      }\n      hasBeenAdded = true\n\n      const parentNode = {\n        ...node\n      }\n\n      if (expandParent) {\n        parentNode.expanded = true\n      }\n\n      // If no children exist yet, just add the single newNode\n      if (!parentNode.children) {\n        insertedTreeIndex = treeIndex + 1\n        return {\n          ...parentNode,\n          children: [newNode]\n        }\n      }\n\n      if (typeof parentNode.children === 'function') {\n        throw new Error('Cannot add to children defined by a function')\n      }\n\n      let nextTreeIndex = treeIndex + 1\n      for (let i = 0; i < parentNode.children.length; i += 1) {\n        nextTreeIndex +=\n          1 +\n          getDescendantCount({ node: parentNode.children[i], ignoreCollapsed })\n      }\n\n      insertedTreeIndex = nextTreeIndex\n\n      const children = addAsFirstChild\n        ? [newNode, ...parentNode.children]\n        : [...parentNode.children, newNode]\n\n      return {\n        ...parentNode,\n        children\n      }\n    }\n  })\n\n  if (!hasBeenAdded) {\n    throw new Error('No node found with the given key.')\n  }\n\n  return {\n    treeData: changedTreeData,\n    treeIndex: insertedTreeIndex\n  }\n}\n\nfunction addNodeAtDepthAndIndex({\n  targetDepth,\n  minimumTreeIndex,\n  newNode,\n  ignoreCollapsed,\n  expandParent,\n  isPseudoRoot = false,\n  isLastChild,\n  node,\n  currentIndex,\n  currentDepth,\n  getNodeKey,\n  path = []\n}) {\n  const selfPath = (n) =>\n    isPseudoRoot\n      ? []\n      : [...path, getNodeKey({ node: n, treeIndex: currentIndex })]\n\n  // If the current position is the only possible place to add, add it\n  if (\n    currentIndex >= minimumTreeIndex - 1 ||\n    (isLastChild && !(node.children && node.children.length))\n  ) {\n    if (typeof node.children === 'function') {\n      throw new Error('Cannot add to children defined by a function')\n    } else {\n      const extraNodeProps = expandParent ? { expanded: true } : {}\n      const nextNode = {\n        ...node,\n\n        ...extraNodeProps,\n        children: node.children ? [newNode, ...node.children] : [newNode]\n      }\n\n      return {\n        node: nextNode,\n        nextIndex: currentIndex + 2,\n        insertedTreeIndex: currentIndex + 1,\n        parentPath: selfPath(nextNode),\n        parentNode: isPseudoRoot ? null : nextNode\n      }\n    }\n  }\n\n  // If this is the target depth for the insertion,\n  // i.e., where the newNode can be added to the current node's children\n  if (currentDepth >= targetDepth - 1) {\n    // Skip over nodes with no children or hidden children\n    if (\n      !node.children ||\n      typeof node.children === 'function' ||\n      (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n    ) {\n      return { node, nextIndex: currentIndex + 1 }\n    }\n\n    // Scan over the children to see if there's a place among them that fulfills\n    // the minimumTreeIndex requirement\n    let childIndex = currentIndex + 1\n    let insertedTreeIndex = null\n    let insertIndex = null\n    for (let i = 0; i < node.children.length; i += 1) {\n      // If a valid location is found, mark it as the insertion location and\n      // break out of the loop\n      if (childIndex >= minimumTreeIndex) {\n        insertedTreeIndex = childIndex\n        insertIndex = i\n        break\n      }\n\n      // Increment the index by the child itself plus the number of descendants it has\n      childIndex +=\n        1 + getDescendantCount({ node: node.children[i], ignoreCollapsed })\n    }\n\n    // If no valid indices to add the node were found\n    if (insertIndex === null) {\n      // If the last position in this node's children is less than the minimum index\n      // and there are more children on the level of this node, return without insertion\n      if (childIndex < minimumTreeIndex && !isLastChild) {\n        return { node, nextIndex: childIndex }\n      }\n\n      // Use the last position in the children array to insert the newNode\n      insertedTreeIndex = childIndex\n      insertIndex = node.children.length\n    }\n\n    // Insert the newNode at the insertIndex\n    const nextNode = {\n      ...node,\n      children: [\n        ...node.children.slice(0, insertIndex),\n        newNode,\n        ...node.children.slice(insertIndex)\n      ]\n    }\n\n    // Return node with successful insert result\n    return {\n      node: nextNode,\n      nextIndex: childIndex,\n      insertedTreeIndex,\n      parentPath: selfPath(nextNode),\n      parentNode: isPseudoRoot ? null : nextNode\n    }\n  }\n\n  // Skip over nodes with no children or hidden children\n  if (\n    !node.children ||\n    typeof node.children === 'function' ||\n    (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n  ) {\n    return { node, nextIndex: currentIndex + 1 }\n  }\n\n  // Get all descendants\n  let insertedTreeIndex = null\n  let pathFragment = null\n  let parentNode = null\n  let childIndex = currentIndex + 1\n  let newChildren = node.children\n  if (typeof newChildren !== 'function') {\n    newChildren = newChildren.map((child, i) => {\n      if (insertedTreeIndex !== null) {\n        return child\n      }\n\n      const mapResult = addNodeAtDepthAndIndex({\n        targetDepth,\n        minimumTreeIndex,\n        newNode,\n        ignoreCollapsed,\n        expandParent,\n        isLastChild: isLastChild && i === newChildren.length - 1,\n        node: child,\n        currentIndex: childIndex,\n        currentDepth: currentDepth + 1,\n        getNodeKey,\n        path: [] // Cannot determine the parent path until the children have been processed\n      })\n\n      if ('insertedTreeIndex' in mapResult) {\n        ;({\n          insertedTreeIndex,\n          parentNode,\n          parentPath: pathFragment\n        } = mapResult)\n      }\n\n      childIndex = mapResult.nextIndex\n\n      return mapResult.node\n    })\n  }\n\n  const nextNode = { ...node, children: newChildren }\n  const result = {\n    node: nextNode,\n    nextIndex: childIndex\n  }\n\n  if (insertedTreeIndex !== null) {\n    result.insertedTreeIndex = insertedTreeIndex\n    result.parentPath = [...selfPath(nextNode), ...pathFragment]\n    result.parentNode = parentNode\n  }\n\n  return result\n}\n\n/**\n * Insert a node into the tree at the given depth, after the minimum index\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} depth - The depth to insert the node at (the first level of the array being depth 0)\n * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\n * @param {!Object} newNode - The node to insert into the tree\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parent of the inserted node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node added\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\n * @return {Object} result.parentNode - The parent node of the inserted node\n */\nexport function insertNode({\n  treeData,\n  depth: targetDepth,\n  minimumTreeIndex,\n  newNode,\n  getNodeKey = () => {},\n  ignoreCollapsed = true,\n  expandParent = false\n}) {\n  if (!treeData && targetDepth === 0) {\n    return {\n      treeData: [newNode],\n      treeIndex: 0,\n      path: [getNodeKey({ node: newNode, treeIndex: 0 })],\n      parentNode: null\n    }\n  }\n\n  const insertResult = addNodeAtDepthAndIndex({\n    targetDepth,\n    minimumTreeIndex,\n    newNode,\n    ignoreCollapsed,\n    expandParent,\n    getNodeKey,\n    isPseudoRoot: true,\n    isLastChild: true,\n    node: { children: treeData },\n    currentIndex: -1,\n    currentDepth: -1\n  })\n\n  if (!('insertedTreeIndex' in insertResult)) {\n    throw new Error('No suitable position found to insert.')\n  }\n\n  const treeIndex = insertResult.insertedTreeIndex\n  return {\n    treeData: insertResult.node.children,\n    treeIndex,\n    path: [\n      ...insertResult.parentPath,\n      getNodeKey({ node: newNode, treeIndex })\n    ],\n    parentNode: insertResult.parentNode\n  }\n}\n\n/**\n * Get tree data flattened.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }}[] nodes - The node array\n */\nexport function getFlatDataFromTree({\n  treeData,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  if (!treeData || treeData.length < 1) {\n    return []\n  }\n\n  const flattened = []\n  walk({\n    treeData,\n    getNodeKey,\n    ignoreCollapsed,\n    callback: (nodeInfo) => {\n      flattened.push(nodeInfo)\n    }\n  })\n\n  return flattened\n}\n\n/**\n * Generate a tree structure from flat data.\n *\n * @param {!Object[]} flatData\n * @param {!function=} getKey - Function to get the key from the nodeData\n * @param {!function=} getParentKey - Function to get the parent key from the nodeData\n * @param {string|number=} rootKey - The value returned by `getParentKey` that corresponds to the root node.\n *                                  For example, if your nodes have id 1-99, you might use rootKey = 0\n *\n * @return {Object[]} treeData - The flat data represented as a tree\n */\nexport function getTreeFromFlatData({\n  flatData,\n  getKey = (node) => node.id,\n  getParentKey = (node) => node.parentId,\n  rootKey = '0'\n}) {\n  if (!flatData) {\n    return []\n  }\n\n  const childrenToParents = {}\n  flatData.forEach((child) => {\n    const parentKey = getParentKey(child)\n\n    if (parentKey in childrenToParents) {\n      childrenToParents[parentKey].push(child)\n    } else {\n      childrenToParents[parentKey] = [child]\n    }\n  })\n\n  if (!(rootKey in childrenToParents)) {\n    return []\n  }\n\n  const trav = (parent) => {\n    const parentKey = getKey(parent)\n    if (parentKey in childrenToParents) {\n      return {\n        ...parent,\n        children: childrenToParents[parentKey].map((child) => trav(child))\n      }\n    }\n\n    return { ...parent }\n  }\n\n  return childrenToParents[rootKey].map((child) => trav(child))\n}\n\n/**\n * Check if a node is a descendant of another node.\n *\n * @param {!Object} older - Potential ancestor of younger node\n * @param {!Object} younger - Potential descendant of older node\n *\n * @return {boolean}\n */\nexport function isDescendant(older, younger) {\n  return (\n    !!older.children &&\n    typeof older.children !== 'function' &&\n    older.children.some(\n      (child) => child === younger || isDescendant(child, younger)\n    )\n  )\n}\n\n/**\n * Get the maximum depth of the children (the depth of the root node is 0).\n *\n * @param {!Object} node - Node in the tree\n * @param {?number} depth - The current depth\n *\n * @return {number} maxDepth - The deepest depth in the tree\n */\nexport function getDepth(node, depth = 0) {\n  if (!node.children) {\n    return depth\n  }\n\n  if (typeof node.children === 'function') {\n    return depth + 1\n  }\n\n  return node.children.reduce(\n    (deepest, child) => Math.max(deepest, getDepth(child, depth + 1)),\n    depth\n  )\n}\n\n/**\n * Find nodes matching a search query in the tree,\n *\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {!Object[]} treeData - Tree data\n * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\n * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\n * @param {?number} searchFocusOffset - The offset of the match to focus on\n *                                      (e.g., 0 focuses on the first match, 1 on the second)\n * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\n * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\n *\n * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\n * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\n *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\n *                               it will be the same as the original tree data.\n */\nexport function find({\n  getNodeKey,\n  treeData,\n  searchQuery,\n  searchMethod,\n  searchFocusOffset,\n  expandAllMatchPaths = false,\n  expandFocusMatchPaths = true\n}) {\n  let matchCount = 0\n  const trav = ({ isPseudoRoot = false, node, currentIndex, path = [] }) => {\n    let matches = []\n    let isSelfMatch = false\n    let hasFocusMatch = false\n    // The pseudo-root is not considered in the path\n    const selfPath = isPseudoRoot\n      ? []\n      : [...path, getNodeKey({ node, treeIndex: currentIndex })]\n    const extraInfo = isPseudoRoot\n      ? null\n      : {\n          path: selfPath,\n          treeIndex: currentIndex\n        }\n\n    // Nodes with with children that aren't lazy\n    const hasChildren =\n      node.children &&\n      typeof node.children !== 'function' &&\n      node.children.length > 0\n\n    // Examine the current node to see if it is a match\n    if (!isPseudoRoot && searchMethod({ ...extraInfo, node, searchQuery })) {\n      if (matchCount === searchFocusOffset) {\n        hasFocusMatch = true\n      }\n\n      // Keep track of the number of matching nodes, so we know when the searchFocusOffset\n      //  is reached\n      matchCount += 1\n\n      // We cannot add this node to the matches right away, as it may be changed\n      //  during the search of the descendants. The entire node is used in\n      //  comparisons between nodes inside the `matches` and `treeData` results\n      //  of this method (`find`)\n      isSelfMatch = true\n    }\n\n    let childIndex = currentIndex\n    const newNode = { ...node }\n    if (hasChildren) {\n      // Get all descendants\n      newNode.children = newNode.children.map((child) => {\n        const mapResult = trav({\n          node: child,\n          currentIndex: childIndex + 1,\n          path: selfPath\n        })\n\n        // Ignore hidden nodes by only advancing the index counter to the returned treeIndex\n        // if the child is expanded.\n        //\n        // The child could have been expanded from the start,\n        // or expanded due to a matching node being found in its descendants\n        if (mapResult.node.expanded) {\n          childIndex = mapResult.treeIndex\n        } else {\n          childIndex += 1\n        }\n\n        if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {\n          matches = [...matches, ...mapResult.matches]\n          if (mapResult.hasFocusMatch) {\n            hasFocusMatch = true\n          }\n\n          // Expand the current node if it has descendants matching the search\n          // and the settings are set to do so.\n          if (\n            (expandAllMatchPaths && mapResult.matches.length > 0) ||\n            ((expandAllMatchPaths || expandFocusMatchPaths) &&\n              mapResult.hasFocusMatch)\n          ) {\n            newNode.expanded = true\n          }\n        }\n\n        return mapResult.node\n      })\n    }\n\n    // Cannot assign a treeIndex to hidden nodes\n    if (!isPseudoRoot && !newNode.expanded) {\n      matches = matches.map((match) => ({\n        ...match,\n        treeIndex: null\n      }))\n    }\n\n    // Add this node to the matches if it fits the search criteria.\n    // This is performed at the last minute so newNode can be sent in its final form.\n    if (isSelfMatch) {\n      matches = [{ ...extraInfo, node: newNode }, ...matches]\n    }\n\n    return {\n      node: matches.length > 0 ? newNode : node,\n      matches,\n      hasFocusMatch,\n      treeIndex: childIndex\n    }\n  }\n\n  const result = trav({\n    node: { children: treeData },\n    isPseudoRoot: true,\n    currentIndex: -1\n  })\n\n  return {\n    matches: result.matches,\n    treeData: result.node.children\n  }\n}\n"],"names":["getNodeDataAtTreeIndexOrNextIndex","_ref","targetIndex","node","currentIndex","getNodeKey","_ref$path","path","_ref$lowerSiblingCoun","lowerSiblingCounts","_ref$ignoreCollapsed","ignoreCollapsed","_ref$isPseudoRoot","isPseudoRoot","selfPath","concat","_toConsumableArray","treeIndex","children","expanded","nextIndex","childIndex","childCount","length","i","result","getDescendantCount","_ref2","_ref2$ignoreCollapsed","walkDescendants","_ref3","callback","_ref3$isPseudoRoot","_ref3$parentNode","parentNode","_ref3$path","_ref3$lowerSiblingCou","selfInfo","callbackResult","mapDescendants","_ref4","_ref4$isPseudoRoot","_ref4$parentNode","_ref4$path","_ref4$lowerSiblingCou","nextNode","_objectSpread","map","child","mapResult","getVisibleNodeCount","_ref5","treeData","traverse","reduce","total","currentNode","getVisibleNodeInfoAtIndex","_ref6","index","walk","_ref7","_ref7$ignoreCollapsed","_ref8","_ref8$ignoreCollapsed","toggleExpandedForAll","_ref9","_ref9$expanded","_ref10","_ref11","changeNodeAtPath","_ref12","newNode","_ref12$ignoreCollapse","RESULT_MISS","_ref13","_ref13$isPseudoRoot","currentTreeIndex","pathIndex","Error","nextTreeIndex","slice","removeNodeAtPath","_ref14","_ref14$ignoreCollapse","removeNode","_ref15","_ref15$ignoreCollapse","removedNode","removedTreeIndex","nextTreeData","_ref16","getNodeAtPath","_ref17","_ref17$ignoreCollapse","foundNodeInfo","_ref18","err","addNodeUnderParent","_ref19","_ref19$parentKey","parentKey","_ref19$ignoreCollapse","_ref19$expandParent","expandParent","_ref19$addAsFirstChil","addAsFirstChild","insertedTreeIndex","hasBeenAdded","changedTreeData","_ref20","key","addNodeAtDepthAndIndex","_ref21","targetDepth","minimumTreeIndex","_ref21$isPseudoRoot","isLastChild","currentDepth","_ref21$path","n","extraNodeProps","parentPath","insertIndex","pathFragment","newChildren","insertNode","_ref22","depth","_ref22$getNodeKey","_ref22$ignoreCollapse","_ref22$expandParent","insertResult","getFlatDataFromTree","_ref23","_ref23$ignoreCollapse","flattened","nodeInfo","push","getTreeFromFlatData","_ref24","flatData","_ref24$getKey","getKey","id","_ref24$getParentKey","getParentKey","parentId","_ref24$rootKey","rootKey","childrenToParents","forEach","trav","parent","isDescendant","older","younger","some","getDepth","arguments","undefined","deepest","Math","max","find","_ref25","searchQuery","searchMethod","searchFocusOffset","_ref25$expandAllMatch","expandAllMatchPaths","_ref25$expandFocusMat","expandFocusMatchPaths","matchCount","_ref26","_ref26$isPseudoRoot","_ref26$path","matches","isSelfMatch","hasFocusMatch","extraInfo","hasChildren","match"],"mappings":"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"}