{"version":3,"file":"StateBase.js","sources":["../../node_modules/immer/dist/immer.module.js","../../src/event/StateBase.js"],"sourcesContent":["var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar NOTHING = typeof Symbol !== \"undefined\" ? Symbol(\"immer-nothing\") : defineProperty({}, \"immer-nothing\", true);\n\nvar DRAFT_STATE = typeof Symbol !== \"undefined\" ? Symbol(\"immer-state\") : \"__$immer_state\";\n\nfunction isDraft(value) {\n    return !!value && !!value[DRAFT_STATE];\n}\n\nfunction isDraftable(value) {\n    if (!value) return false;\n    if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== \"object\") return false;\n    if (Array.isArray(value)) return true;\n    var proto = Object.getPrototypeOf(value);\n    return proto === null || proto === Object.prototype;\n}\n\nfunction original(value) {\n    if (value && value[DRAFT_STATE]) {\n        return value[DRAFT_STATE].base;\n    }\n    // otherwise return undefined\n}\n\nvar assign = Object.assign || function assign(target, value) {\n    for (var key in value) {\n        if (has(value, key)) {\n            target[key] = value[key];\n        }\n    }\n    return target;\n};\n\nfunction shallowCopy(value) {\n    if (Array.isArray(value)) return value.slice();\n    var target = value.__proto__ === undefined ? Object.create(null) : {};\n    return assign(target, value);\n}\n\nfunction each(value, cb) {\n    if (Array.isArray(value)) {\n        for (var i = 0; i < value.length; i++) {\n            cb(i, value[i], value);\n        }\n    } else {\n        for (var key in value) {\n            cb(key, value[key], value);\n        }\n    }\n}\n\nfunction has(thing, prop) {\n    return Object.prototype.hasOwnProperty.call(thing, prop);\n}\n\nfunction is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y;\n    } else {\n        return x !== x && y !== y;\n    }\n}\n\nfunction generatePatches(state, basePath, patches, inversePatches) {\n    Array.isArray(state.base) ? generateArrayPatches(state, basePath, patches, inversePatches) : generateObjectPatches(state, basePath, patches, inversePatches);\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n    var base = state.base,\n        copy = state.copy,\n        assigned = state.assigned;\n\n    var minLength = Math.min(base.length, copy.length);\n\n    // Look for replaced indices.\n    for (var i = 0; i < minLength; i++) {\n        if (assigned[i] && base[i] !== copy[i]) {\n            var path = basePath.concat(i);\n            patches.push({ op: \"replace\", path: path, value: copy[i] });\n            inversePatches.push({ op: \"replace\", path: path, value: base[i] });\n        }\n    }\n\n    // Did the array expand?\n    if (minLength < copy.length) {\n        for (var _i = minLength; _i < copy.length; _i++) {\n            patches.push({\n                op: \"add\",\n                path: basePath.concat(_i),\n                value: copy[_i]\n            });\n        }\n        inversePatches.push({\n            op: \"replace\",\n            path: basePath.concat(\"length\"),\n            value: base.length\n        });\n    }\n\n    // ...or did it shrink?\n    else if (minLength < base.length) {\n            patches.push({\n                op: \"replace\",\n                path: basePath.concat(\"length\"),\n                value: copy.length\n            });\n            for (var _i2 = minLength; _i2 < base.length; _i2++) {\n                inversePatches.push({\n                    op: \"add\",\n                    path: basePath.concat(_i2),\n                    value: base[_i2]\n                });\n            }\n        }\n}\n\nfunction generateObjectPatches(state, basePath, patches, inversePatches) {\n    var base = state.base,\n        copy = state.copy;\n\n    each(state.assigned, function (key, assignedValue) {\n        var origValue = base[key];\n        var value = copy[key];\n        var op = !assignedValue ? \"remove\" : key in base ? \"replace\" : \"add\";\n        if (origValue === base && op === \"replace\") return;\n        var path = basePath.concat(key);\n        patches.push(op === \"remove\" ? { op: op, path: path } : { op: op, path: path, value: value });\n        inversePatches.push(op === \"add\" ? { op: \"remove\", path: path } : op === \"remove\" ? { op: \"add\", path: path, value: origValue } : { op: \"replace\", path: path, value: origValue });\n    });\n}\n\nfunction applyPatches(draft, patches) {\n    for (var i = 0; i < patches.length; i++) {\n        var patch = patches[i];\n        var path = patch.path;\n\n        if (path.length === 0 && patch.op === \"replace\") {\n            draft = patch.value;\n        } else {\n            var base = draft;\n            for (var _i3 = 0; _i3 < path.length - 1; _i3++) {\n                base = base[path[_i3]];\n                if (!base || (typeof base === \"undefined\" ? \"undefined\" : _typeof(base)) !== \"object\") throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")); // prettier-ignore\n            }\n            var key = path[path.length - 1];\n            switch (patch.op) {\n                case \"replace\":\n                case \"add\":\n                    // TODO: add support is not extensive, it does not support insertion or `-` atm!\n                    base[key] = patch.value;\n                    break;\n                case \"remove\":\n                    if (Array.isArray(base)) {\n                        if (key !== base.length - 1) throw new Error(\"Only the last index of an array can be removed, index: \" + key + \", length: \" + base.length); // prettier-ignore\n                        base.length -= 1;\n                    } else {\n                        delete base[key];\n                    }\n                    break;\n                default:\n                    throw new Error(\"Unsupported patch operation: \" + patch.op);\n            }\n        }\n    }\n    return draft;\n}\n\n// @ts-check\n\nvar descriptors = {};\n\n// For nested produce calls:\nvar scopes = [];\nvar currentScope = function currentScope() {\n    return scopes[scopes.length - 1];\n};\n\nfunction willFinalize(result, baseDraft, needPatches) {\n    var scope = currentScope();\n    scope.forEach(function (state) {\n        return state.finalizing = true;\n    });\n    if (result === undefined || result === baseDraft) {\n        if (needPatches) markChangesRecursively(baseDraft);\n        // This is faster when we don't care about which attributes changed.\n        markChangesSweep(scope);\n    }\n}\n\nfunction createDraft(base, parent) {\n    var draft = void 0;\n    if (isDraft(base)) {\n        var _state = base[DRAFT_STATE];\n        // Avoid creating new drafts when copying.\n        _state.finalizing = true;\n        draft = shallowCopy(_state.draft);\n        _state.finalizing = false;\n    } else {\n        draft = shallowCopy(base);\n    }\n    each(base, function (prop) {\n        Object.defineProperty(draft, \"\" + prop, createPropertyProxy(\"\" + prop));\n    });\n\n    // See \"proxy.js\" for property documentation.\n    var state = {\n        scope: parent ? parent.scope : currentScope(),\n        modified: false,\n        finalizing: false, // es5 only\n        finalized: false,\n        assigned: {},\n        parent: parent,\n        base: base,\n        draft: draft,\n        copy: null,\n        revoke: revoke,\n        revoked: false // es5 only\n    };\n\n    createHiddenProperty(draft, DRAFT_STATE, state);\n    state.scope.push(state);\n    return draft;\n}\n\nfunction revoke() {\n    this.revoked = true;\n}\n\nfunction source(state) {\n    return state.copy || state.base;\n}\n\nfunction _get(state, prop) {\n    assertUnrevoked(state);\n    var value = source(state)[prop];\n    // Drafts are only created for proxyable values that exist in the base state.\n    if (!state.finalizing && value === state.base[prop] && isDraftable(value)) {\n        prepareCopy(state);\n        return state.copy[prop] = createDraft(value, state);\n    }\n    return value;\n}\n\nfunction _set(state, prop, value) {\n    assertUnrevoked(state);\n    state.assigned[prop] = true;\n    if (!state.modified) {\n        if (is(source(state)[prop], value)) return;\n        markChanged(state);\n        prepareCopy(state);\n    }\n    state.copy[prop] = value;\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true;\n        if (state.parent) markChanged(state.parent);\n    }\n}\n\nfunction prepareCopy(state) {\n    if (!state.copy) state.copy = shallowCopy(state.base);\n}\n\nfunction createPropertyProxy(prop) {\n    return descriptors[prop] || (descriptors[prop] = {\n        configurable: true,\n        enumerable: true,\n        get: function get$$1() {\n            return _get(this[DRAFT_STATE], prop);\n        },\n        set: function set$$1(value) {\n            _set(this[DRAFT_STATE], prop, value);\n        }\n    });\n}\n\nfunction assertUnrevoked(state) {\n    if (state.revoked === true) throw new Error(\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + JSON.stringify(state.copy || state.base));\n}\n\n// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\nfunction markChangesSweep(scope) {\n    // The natural order of drafts in the `scope` array is based on when they\n    // were accessed. By processing drafts in reverse natural order, we have a\n    // better chance of processing leaf nodes first. When a leaf node is known to\n    // have changed, we can avoid any traversal of its ancestor nodes.\n    for (var i = scope.length - 1; i >= 0; i--) {\n        var state = scope[i];\n        if (state.modified === false) {\n            if (Array.isArray(state.base)) {\n                if (hasArrayChanges(state)) markChanged(state);\n            } else if (hasObjectChanges(state)) markChanged(state);\n        }\n    }\n}\n\nfunction markChangesRecursively(object) {\n    if (!object || (typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) !== \"object\") return;\n    var state = object[DRAFT_STATE];\n    if (!state) return;\n    var base = state.base,\n        draft = state.draft,\n        assigned = state.assigned;\n\n    if (!Array.isArray(object)) {\n        // Look for added keys.\n        Object.keys(draft).forEach(function (key) {\n            // The `undefined` check is a fast path for pre-existing keys.\n            if (base[key] === undefined && !has(base, key)) {\n                assigned[key] = true;\n                markChanged(state);\n            } else if (!assigned[key]) {\n                // Only untouched properties trigger recursion.\n                markChangesRecursively(draft[key]);\n            }\n        });\n        // Look for removed keys.\n        Object.keys(base).forEach(function (key) {\n            // The `undefined` check is a fast path for pre-existing keys.\n            if (draft[key] === undefined && !has(draft, key)) {\n                assigned[key] = false;\n                markChanged(state);\n            }\n        });\n    } else if (hasArrayChanges(state)) {\n        markChanged(state);\n        assigned.length = true;\n        if (draft.length < base.length) {\n            for (var i = draft.length; i < base.length; i++) {\n                assigned[i] = false;\n            }\n        } else {\n            for (var _i = base.length; _i < draft.length; _i++) {\n                assigned[_i] = true;\n            }\n        }\n        for (var _i2 = 0; _i2 < draft.length; _i2++) {\n            // Only untouched indices trigger recursion.\n            if (assigned[_i2] === undefined) markChangesRecursively(draft[_i2]);\n        }\n    }\n}\n\nfunction hasObjectChanges(state) {\n    var base = state.base,\n        draft = state.draft;\n\n    // Search for added keys. Start at the back, because non-numeric keys\n    // are ordered by time of definition on the object.\n\n    var keys = Object.keys(draft);\n    for (var i = keys.length - 1; i >= 0; i--) {\n        // The `undefined` check is a fast path for pre-existing keys.\n        if (base[keys[i]] === undefined && !has(base, keys[i])) {\n            return true;\n        }\n    }\n\n    // Since no keys have been added, we can compare lengths to know if an\n    // object has been deleted.\n    return keys.length !== Object.keys(base).length;\n}\n\nfunction hasArrayChanges(state) {\n    var draft = state.draft;\n\n    if (draft.length !== state.base.length) return true;\n    // See #116\n    // If we first shorten the length, our array interceptors will be removed.\n    // If after that new items are added, result in the same original length,\n    // those last items will have no intercepting property.\n    // So if there is no own descriptor on the last position, we know that items were removed and added\n    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n    // the last one\n    var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1);\n    // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n    if (descriptor && !descriptor.get) return true;\n    // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n    return false;\n}\n\nfunction createHiddenProperty(target, prop, value) {\n    Object.defineProperty(target, prop, {\n        value: value,\n        enumerable: false,\n        writable: true\n    });\n}\n\n\n\nvar legacyProxy = Object.freeze({\n\tscopes: scopes,\n\tcurrentScope: currentScope,\n\twillFinalize: willFinalize,\n\tcreateDraft: createDraft\n});\n\n// @ts-check\n\n// For nested produce calls:\nvar scopes$1 = [];\nvar currentScope$1 = function currentScope() {\n    return scopes$1[scopes$1.length - 1];\n};\n\n// Do nothing before being finalized.\nfunction willFinalize$1() {}\n\nfunction createDraft$1(base, parent) {\n    var state = {\n        // Track which produce call this is associated with.\n        scope: parent ? parent.scope : currentScope$1(),\n        // True for both shallow and deep changes.\n        modified: false,\n        // Used during finalization.\n        finalized: false,\n        // Track which properties have been assigned (true) or deleted (false).\n        assigned: {},\n        // The parent draft state.\n        parent: parent,\n        // The base state.\n        base: base,\n        // The base proxy.\n        draft: null,\n        // Any property proxies.\n        drafts: {},\n        // The base copy with any updated values.\n        copy: null,\n        // Called by the `produce` function.\n        revoke: null\n    };\n\n    var _ref = Array.isArray(base) ? Proxy.revocable([state], arrayTraps) : Proxy.revocable(state, objectTraps),\n        revoke = _ref.revoke,\n        proxy = _ref.proxy;\n\n    state.draft = proxy;\n    state.revoke = revoke;\n\n    state.scope.push(state);\n    return proxy;\n}\n\nvar objectTraps = {\n    get: get$1,\n    has: function has$$1(target, prop) {\n        return prop in source$1(target);\n    },\n    ownKeys: function ownKeys(target) {\n        return Reflect.ownKeys(source$1(target));\n    },\n\n    set: set$1,\n    deleteProperty: deleteProperty,\n    getOwnPropertyDescriptor: getOwnPropertyDescriptor,\n    defineProperty: defineProperty$1,\n    setPrototypeOf: function setPrototypeOf() {\n        throw new Error(\"Immer does not support `setPrototypeOf()`.\");\n    }\n};\n\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n    arrayTraps[key] = function () {\n        arguments[0] = arguments[0][0];\n        return fn.apply(this, arguments);\n    };\n});\narrayTraps.deleteProperty = function (state, prop) {\n    if (isNaN(parseInt(prop))) throw new Error(\"Immer does not support deleting properties from arrays: \" + prop);\n    return objectTraps.deleteProperty.call(this, state[0], prop);\n};\narrayTraps.set = function (state, prop, value) {\n    if (prop !== \"length\" && isNaN(parseInt(prop))) throw new Error(\"Immer does not support setting non-numeric properties on arrays: \" + prop);\n    return objectTraps.set.call(this, state[0], prop, value);\n};\n\nfunction source$1(state) {\n    return state.copy || state.base;\n}\n\nfunction get$1(state, prop) {\n    if (prop === DRAFT_STATE) return state;\n    var drafts = state.drafts;\n\n    // Check for existing draft in unmodified state.\n\n    if (!state.modified && has(drafts, prop)) {\n        return drafts[prop];\n    }\n\n    var value = source$1(state)[prop];\n    if (state.finalized || !isDraftable(value)) return value;\n\n    // Check for existing draft in modified state.\n    if (state.modified) {\n        // Assigned values are never drafted. This catches any drafts we created, too.\n        if (value !== state.base[prop]) return value;\n        // Store drafts on the copy (when one exists).\n        drafts = state.copy;\n    }\n\n    return drafts[prop] = createDraft$1(value, state);\n}\n\nfunction set$1(state, prop, value) {\n    if (!state.modified) {\n        // Optimize based on value's truthiness. Truthy values are guaranteed to\n        // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n        // values may be drafts, but falsy values are never drafts.\n        var isUnchanged = value ? is(state.base[prop], value) || value === state.drafts[prop] : is(state.base[prop], value) && prop in state.base;\n        if (isUnchanged) return true;\n        markChanged$1(state);\n    }\n    state.assigned[prop] = true;\n    state.copy[prop] = value;\n    return true;\n}\n\nfunction deleteProperty(state, prop) {\n    // The `undefined` check is a fast path for pre-existing keys.\n    if (state.base[prop] !== undefined || prop in state.base) {\n        state.assigned[prop] = false;\n        markChanged$1(state);\n    }\n    if (state.copy) delete state.copy[prop];\n    return true;\n}\n\nfunction getOwnPropertyDescriptor(state, prop) {\n    var owner = state.modified ? state.copy : has(state.drafts, prop) ? state.drafts : state.base;\n    var descriptor = Reflect.getOwnPropertyDescriptor(owner, prop);\n    if (descriptor && !(Array.isArray(owner) && prop === \"length\")) descriptor.configurable = true;\n    return descriptor;\n}\n\nfunction defineProperty$1() {\n    throw new Error(\"Immer does not support defining properties on draft objects.\");\n}\n\nfunction markChanged$1(state) {\n    if (!state.modified) {\n        state.modified = true;\n        state.copy = assign(shallowCopy(state.base), state.drafts);\n        state.drafts = null;\n        if (state.parent) markChanged$1(state.parent);\n    }\n}\n\nvar modernProxy = Object.freeze({\n\tscopes: scopes$1,\n\tcurrentScope: currentScope$1,\n\twillFinalize: willFinalize$1,\n\tcreateDraft: createDraft$1\n});\n\nfunction verifyMinified() {}\n\nvar configDefaults = {\n    useProxies: typeof Proxy !== \"undefined\" && typeof Reflect !== \"undefined\",\n    autoFreeze: typeof process !== \"undefined\" ? process.env.NODE_ENV !== \"production\" : verifyMinified.name === \"verifyMinified\",\n    onAssign: null,\n    onDelete: null,\n    onCopy: null\n};\n\nvar Immer = function () {\n    function Immer(config) {\n        classCallCheck(this, Immer);\n\n        assign(this, configDefaults, config);\n        this.setUseProxies(this.useProxies);\n        this.produce = this.produce.bind(this);\n    }\n\n    createClass(Immer, [{\n        key: \"produce\",\n        value: function produce(base, recipe, patchListener) {\n            var _this = this;\n\n            // curried invocation\n            if (typeof base === \"function\" && typeof recipe !== \"function\") {\n                var defaultBase = recipe;\n                recipe = base;\n\n                // prettier-ignore\n                return function () {\n                    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                        args[_key - 1] = arguments[_key];\n                    }\n\n                    var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultBase;\n                    return _this.produce(base, function (draft) {\n                        var _recipe;\n\n                        return (_recipe = recipe).call.apply(_recipe, [draft, draft].concat(args));\n                    });\n                };\n            }\n\n            // prettier-ignore\n            {\n                if (typeof recipe !== \"function\") throw new Error(\"if first argument is not a function, the second argument to produce should be a function\");\n                if (patchListener !== undefined && typeof patchListener !== \"function\") throw new Error(\"the third argument of a producer should not be set or a function\");\n            }\n\n            var result = void 0;\n            // Only create proxies for plain objects/arrays.\n            if (!isDraftable(base)) {\n                result = recipe(base);\n                if (result === undefined) return base;\n            }\n            // See #100, don't nest producers\n            else if (isDraft(base)) {\n                    result = recipe.call(base, base);\n                    if (result === undefined) return base;\n                }\n                // The given value must be proxied.\n                else {\n                        this.scopes.push([]);\n                        var baseDraft = this.createDraft(base);\n                        try {\n                            result = recipe.call(baseDraft, baseDraft);\n                            this.willFinalize(result, baseDraft, !!patchListener);\n\n                            // Never generate patches when no listener exists.\n                            var patches = patchListener && [],\n                                inversePatches = patchListener && [];\n\n                            // Finalize the modified draft...\n                            if (result === undefined || result === baseDraft) {\n                                result = this.finalize(baseDraft, [], patches, inversePatches);\n                            }\n                            // ...or use a replacement value.\n                            else {\n                                    // Users must never modify the draft _and_ return something else.\n                                    if (baseDraft[DRAFT_STATE].modified) throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"); // prettier-ignore\n\n                                    // Finalize the replacement in case it contains (or is) a subset of the draft.\n                                    if (isDraftable(result)) result = this.finalize(result);\n\n                                    if (patchListener) {\n                                        patches.push({\n                                            op: \"replace\",\n                                            path: [],\n                                            value: result\n                                        });\n                                        inversePatches.push({\n                                            op: \"replace\",\n                                            path: [],\n                                            value: base\n                                        });\n                                    }\n                                }\n                        } finally {\n                            this.currentScope().forEach(function (state) {\n                                return state.revoke();\n                            });\n                            this.scopes.pop();\n                        }\n                        patchListener && patchListener(patches, inversePatches);\n                    }\n            // Normalize the result.\n            return result === NOTHING ? undefined : result;\n        }\n    }, {\n        key: \"setAutoFreeze\",\n        value: function setAutoFreeze(value) {\n            this.autoFreeze = value;\n        }\n    }, {\n        key: \"setUseProxies\",\n        value: function setUseProxies(value) {\n            this.useProxies = value;\n            assign(this, value ? modernProxy : legacyProxy);\n        }\n        /**\n         * @internal\n         * Finalize a draft, returning either the unmodified base state or a modified\n         * copy of the base state.\n         */\n\n    }, {\n        key: \"finalize\",\n        value: function finalize(draft, path, patches, inversePatches) {\n            var state = draft[DRAFT_STATE];\n            if (!state) {\n                if (Object.isFrozen(draft)) return draft;\n                return this.finalizeTree(draft);\n            }\n            // Never finalize drafts owned by an outer scope.\n            if (state.scope !== this.currentScope()) {\n                return draft;\n            }\n            if (!state.modified) return state.base;\n            if (!state.finalized) {\n                state.finalized = true;\n                this.finalizeTree(state.draft, path, patches, inversePatches);\n                if (this.onDelete) {\n                    var assigned = state.assigned;\n\n                    for (var prop in assigned) {\n                        assigned[prop] || this.onDelete(state, prop);\n                    }\n                }\n                if (this.onCopy) this.onCopy(state);\n\n                // Nested producers must never auto-freeze their result,\n                // because it may contain drafts from parent producers.\n                if (this.autoFreeze && this.scopes.length === 1) {\n                    Object.freeze(state.copy);\n                }\n\n                if (patches) generatePatches(state, path, patches, inversePatches);\n            }\n            return state.copy;\n        }\n        /**\n         * @internal\n         * Finalize all drafts in the given state tree.\n         */\n\n    }, {\n        key: \"finalizeTree\",\n        value: function finalizeTree(root, path, patches, inversePatches) {\n            var _this2 = this;\n\n            var state = root[DRAFT_STATE];\n            if (state) {\n                root = this.useProxies ? state.copy : state.copy = shallowCopy(state.draft);\n            }\n\n            var onAssign = this.onAssign;\n\n            var finalizeProperty = function finalizeProperty(prop, value, parent) {\n                // Only `root` can be a draft in here.\n                var inDraft = !!state && parent === root;\n\n                if (isDraft(value)) {\n                    // prettier-ignore\n                    parent[prop] = value =\n                    // Patches are never generated for assigned properties.\n                    patches && inDraft && !state.assigned[prop] ? _this2.finalize(value, path.concat(prop), patches, inversePatches) : _this2.finalize(value);\n\n                    // Unchanged drafts are ignored.\n                    if (inDraft && value === state.base[prop]) return;\n                }\n                // Unchanged draft properties are ignored.\n                else if (inDraft && is(value, state.base[prop])) {\n                        return;\n                    }\n                    // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n                    else if (isDraftable(value) && !Object.isFrozen(value)) {\n                            each(value, finalizeProperty);\n                        }\n\n                if (inDraft && onAssign) {\n                    onAssign(state, prop, value);\n                }\n            };\n\n            each(root, finalizeProperty);\n            return root;\n        }\n    }]);\n    return Immer;\n}();\n\nvar immer = new Immer();\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nvar produce = immer.produce;\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\nvar setAutoFreeze = function setAutoFreeze(value) {\n  return immer.setAutoFreeze(value);\n};\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nvar setUseProxies = function setUseProxies(value) {\n  return immer.setUseProxies(value);\n};\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nvar applyPatches$1 = produce(applyPatches);\n\nexport { produce, setAutoFreeze, setUseProxies, applyPatches$1 as applyPatches, Immer, original, isDraft, NOTHING as nothing };\nexport default produce;\n//# sourceMappingURL=immer.module.js.map\n","import produce from 'immer'\n\nexport class StateInstance {\n  state = {}\n  mount = null\n\n  /// //////////////////////////////////////////////\n  /// Internal helper functions\n  /// //////////////////////////////////////////////\n\n  __updateObject(target, update) {\n    // applies the changes\n    // for each key/value pair in update object\n    for (const [key, value] of Object.entries(update)) {\n      // if target has the relevant key and\n      // the type in target and update is the same\n      // eslint-disable-next-line no-prototype-builtins\n      if (target.hasOwnProperty(key) && typeof value === typeof target[key]) {\n        // update value if string,number or boolean\n        if (\n          ['string', 'number', 'boolean'].includes(typeof value) ||\n          Array.isArray(value) ||\n          Object.prototype.toString.call(value) === '[object Date]'\n        ) {\n          target[key] = value\n        } else {\n          // if type is object then go one level deeper\n          if (typeof value === 'object') {\n            this.__updateObject(target[key], value)\n          }\n        }\n      }\n    }\n  }\n\n  /// //////////////////////////////////////////////\n  // State functions\n  /// //////////////////////////////////////////////\n\n  getState() {\n    return this.state\n  }\n\n  setState(updated_state, skip_component_update) {\n    // Depricated: replace the current state with this one (legacy support)\n    this.state = updated_state\n    if (skip_component_update) {\n      return\n    }\n    if (this.mount) {\n      if (this.mount.setState) {\n        // make sure this mounted component has setState\n        this.mount.setState(updated_state)\n      }\n    }\n  }\n\n  getActionState(action, callback) {\n    if (this.mount) {\n      if (this.mount.getActionState) {\n        // make sure this mounted component has setState\n        this.mount.getActionState(action, callback)\n      } else {\n        callback()\n      }\n    } else {\n      callback()\n    }\n  }\n\n  alterState(change, skip_component_update) {\n    // does some immer magic (and calls setState)\n    if (change === undefined) {\n      return this.state\n    }\n    if (typeof change === 'object') {\n      const changed = produce(this.state, (draft) => {\n        this.__updateObject(draft, change)\n      })\n      this.setState(changed, skip_component_update)\n      return changed\n    } else {\n      const changed = produce(this.state, change)\n      this.setState(changed, skip_component_update)\n      return changed\n    }\n  }\n\n  /// //////////////////////////////////////////////\n  /// Mounting functions used by visual components\n  /// //////////////////////////////////////////////\n\n  doMount(component_instance) {\n    this.mount = component_instance\n  }\n\n  unMount(component_instance) {\n    this.mount = null\n  }\n\n  updateView(action, arr, updated, data) {\n    // if the component is mounted we notify it to update its view\n    if (this.mount) {\n      if (this.mount.updateView) {\n        this.mount.updateView(action, arr, updated, data)\n      }\n    }\n    return true\n  }\n}\n\nexport class StateLess extends StateInstance {\n  /**\n   * Used to manage internal state of avatars\n   */\n  constructor(props) {\n    super(props)\n    this.props = props\n\n    // check for component manager\n    if (!this.props.manager) {\n      const newLocal =\n        'Manager was not provided through props for component ' + this.props.id\n      throw newLocal\n    }\n    /*\n    // make sure the manager is of correct type\n    if (this.props.manager.constructor.name !== 'ComponentManager') {\n      // eslint-disable-next-line no-throw-literal\n      throw (\n        \"Constructor must be component manager. Got '\" +\n        this.props.manager.constructor.name +\n        \"' for component \" +\n        this.props.id\n      )\n    }\n    */\n\n    this.eventManager = this.props.manager.getEventManager()\n  }\n\n  updateView = (action, arr, updated, data) => {\n    // extend by parent\n    return true\n  }\n\n  triggerEvent(event, data, evt) {\n    this.props.manager\n      .getEventManager()\n      .addEvent(this.props.id, event, data, evt)\n  }\n\n  triggerAction(action, data, evt) {\n    this.props.manager\n      .getEventManager()\n      .addAction(this.props.id, action, data, null, evt)\n  }\n\n  register(actions, events, component_info) {\n    this.props.manager\n      .getEventManager()\n      .register(this.props.id, actions, events, component_info)\n  }\n\n  setInstanceState(state) {\n    if (this.stateManager) {\n      this.stateManager.setState(state)\n    }\n  }\n}\nexport default { StateInstance, StateLess }\n"],"names":["obj","key","value","_typeof","Symbol","iterator","constructor","prototype","createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","Constructor","protoProps","staticProps","NOTHING","DRAFT_STATE","isDraft","isDraftable","Array","isArray","proto","getPrototypeOf","assign","has","shallowCopy","slice","undefined","__proto__","create","each","cb","thing","prop","hasOwnProperty","call","is","x","y","generatePatches","state","basePath","patches","inversePatches","base","copy","assigned","minLength","Math","min","path","concat","push","op","_i","_i2","generateArrayPatches","assignedValue","origValue","generateObjectPatches","descriptors","scopes","currentScope","createDraft","parent","draft","_state","finalizing","get","assertUnrevoked","source","prepareCopy","_get","this","set","modified","markChanged","_set","createPropertyProxy","scope","finalized","revoke","revoked","createHiddenProperty","Error","JSON","stringify","markChangesRecursively","object","hasArrayChanges","keys","forEach","hasObjectChanges","getOwnPropertyDescriptor","legacyProxy","freeze","willFinalize","result","baseDraft","needPatches","markChangesSweep","scopes$1","currentScope$1","createDraft$1","drafts","_ref","Proxy","revocable","arrayTraps","objectTraps","proxy","source$1","ownKeys","Reflect","markChanged$1","deleteProperty","owner","setPrototypeOf","fn","arguments","apply","isNaN","parseInt","modernProxy","configDefaults","useProxies","autoFreeze","process","env","NODE_ENV","name","onAssign","onDelete","onCopy","Immer","config","instance","TypeError","classCallCheck","setUseProxies","produce","bind","recipe","patchListener","_this","defaultBase","_len","args","_key","_recipe","finalize","pop","isFrozen","finalizeTree","root","_this2","finalizeProperty","inDraft","patch","_i3","join","StateInstance","_classCallCheck","_defineProperty","_createClass","update","_Object$entries","entries","_Object$entries$_i","_slicedToArray","includes","toString","__updateObject","updated_state","skip_component_update","mount","setState","action","callback","getActionState","change","changed","component_instance","arr","updated","data","updateView","StateLess","_StateInstance","_inherits","_super","_createSuper","_assertThisInitialized","manager","id","eventManager","getEventManager","event","evt","addEvent","addAction","actions","events","component_info","register","stateManager","StateBase"],"mappings":"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"}