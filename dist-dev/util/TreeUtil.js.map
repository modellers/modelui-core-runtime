{"version":3,"file":"TreeUtil.js","sources":["../../src/util/TreeUtil.js"],"sourcesContent":["// copied as is from\n// https://github.com/frontend-collective/react-sortable-tree/blob/master/src/utils/tree-data-utils.js\n\n/**\n * Performs a depth-first traversal over all of the node descendants,\n * incrementing currentIndex by 1 for each\n */\nfunction getNodeDataAtTreeIndexOrNextIndex({\n  targetIndex,\n  node,\n  currentIndex,\n  getNodeKey,\n  path = [],\n  lowerSiblingCounts = [],\n  ignoreCollapsed = true,\n  isPseudoRoot = false\n}) {\n  // The pseudo-root is not considered in the path\n  const selfPath = !isPseudoRoot\n    ? [...path, getNodeKey({ node, treeIndex: currentIndex })]\n    : []\n\n  // Return target node when found\n  if (currentIndex === targetIndex) {\n    return {\n      node,\n      lowerSiblingCounts,\n      path: selfPath\n    }\n  }\n\n  // Add one and continue for nodes with no children or hidden children\n  if (!node.children || (ignoreCollapsed && node.expanded !== true)) {\n    return { nextIndex: currentIndex + 1 }\n  }\n\n  // Iterate over each child and their descendants and return the\n  // target node if childIndex reaches the targetIndex\n  let childIndex = currentIndex + 1\n  const childCount = node.children.length\n  for (let i = 0; i < childCount; i += 1) {\n    const result = getNodeDataAtTreeIndexOrNextIndex({\n      ignoreCollapsed,\n      getNodeKey,\n      targetIndex,\n      node: node.children[i],\n      currentIndex: childIndex,\n      lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\n      path: selfPath\n    })\n\n    if (result.node) {\n      return result\n    }\n\n    childIndex = result.nextIndex\n  }\n\n  // If the target node is not found, return the farthest traversed index\n  return { nextIndex: childIndex }\n}\n\nexport function getDescendantCount({ node, ignoreCollapsed = true }) {\n  return (\n    getNodeDataAtTreeIndexOrNextIndex({\n      getNodeKey: () => {},\n      ignoreCollapsed,\n      node,\n      currentIndex: 0,\n      targetIndex: -1\n    }).nextIndex - 1\n  )\n}\n\n/**\n * Walk all descendants of the given node, depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\nfunction walkDescendants({\n  callback,\n  getNodeKey,\n  ignoreCollapsed,\n  isPseudoRoot = false,\n  node,\n  parentNode = null,\n  currentIndex,\n  path = [],\n  lowerSiblingCounts = []\n}) {\n  // The pseudo-root is not considered in the path\n  const selfPath = isPseudoRoot\n    ? []\n    : [...path, getNodeKey({ node, treeIndex: currentIndex })]\n  const selfInfo = isPseudoRoot\n    ? null\n    : {\n        node,\n        parentNode,\n        path: selfPath,\n        lowerSiblingCounts,\n        treeIndex: currentIndex\n      }\n\n  if (!isPseudoRoot) {\n    const callbackResult = callback(selfInfo)\n\n    // Cut walk short if the callback returned false\n    if (callbackResult === false) {\n      return false\n    }\n  }\n\n  // Return self on nodes with no children or hidden children\n  if (\n    !node.children ||\n    (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n  ) {\n    return currentIndex\n  }\n\n  // Get all descendants\n  let childIndex = currentIndex\n  const childCount = node.children.length\n  if (typeof node.children !== 'function') {\n    for (let i = 0; i < childCount; i += 1) {\n      childIndex = walkDescendants({\n        callback,\n        getNodeKey,\n        ignoreCollapsed,\n        node: node.children[i],\n        parentNode: isPseudoRoot ? null : node,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\n        path: selfPath\n      })\n\n      // Cut walk short if the callback returned false\n      if (childIndex === false) {\n        return false\n      }\n    }\n  }\n\n  return childIndex\n}\n\n/**\n * Perform a change on the given node and all its descendants, traversing the tree depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\nfunction mapDescendants({\n  callback,\n  getNodeKey,\n  ignoreCollapsed,\n  isPseudoRoot = false,\n  node,\n  parentNode = null,\n  currentIndex,\n  path = [],\n  lowerSiblingCounts = []\n}) {\n  const nextNode = { ...node }\n\n  // The pseudo-root is not considered in the path\n  const selfPath = isPseudoRoot\n    ? []\n    : [...path, getNodeKey({ node: nextNode, treeIndex: currentIndex })]\n  const selfInfo = {\n    node: nextNode,\n    parentNode,\n    path: selfPath,\n    lowerSiblingCounts,\n    treeIndex: currentIndex\n  }\n\n  // Return self on nodes with no children or hidden children\n  if (\n    !nextNode.children ||\n    (nextNode.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n  ) {\n    return {\n      treeIndex: currentIndex,\n      node: callback(selfInfo)\n    }\n  }\n\n  // Get all descendants\n  let childIndex = currentIndex\n  const childCount = nextNode.children.length\n  if (typeof nextNode.children !== 'function') {\n    nextNode.children = nextNode.children.map((child, i) => {\n      const mapResult = mapDescendants({\n        callback,\n        getNodeKey,\n        ignoreCollapsed,\n        node: child,\n        parentNode: isPseudoRoot ? null : nextNode,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\n        path: selfPath\n      })\n      childIndex = mapResult.treeIndex\n\n      return mapResult.node\n    })\n  }\n\n  return {\n    node: callback(selfInfo),\n    treeIndex: childIndex\n  }\n}\n\n/**\n * Count all the visible (expanded) descendants in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n *\n * @return {number} count\n */\nexport function getVisibleNodeCount({ treeData }) {\n  const traverse = (node) => {\n    if (\n      !node.children ||\n      node.expanded !== true ||\n      typeof node.children === 'function'\n    ) {\n      return 1\n    }\n\n    return (\n      1 +\n      node.children.reduce(\n        (total, currentNode) => total + traverse(currentNode),\n        0\n      )\n    )\n  }\n\n  return treeData.reduce(\n    (total, currentNode) => total + traverse(currentNode),\n    0\n  )\n}\n\n/**\n * Get the <targetIndex>th visible node in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} targetIndex - The index of the node to search for\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }|null} node - The node at targetIndex, or null if not found\n */\nexport function getVisibleNodeInfoAtIndex({\n  treeData,\n  index: targetIndex,\n  getNodeKey\n}) {\n  if (!treeData || treeData.length < 1) {\n    return null\n  }\n\n  // Call the tree traversal with a pseudo-root node\n  const result = getNodeDataAtTreeIndexOrNextIndex({\n    targetIndex,\n    getNodeKey,\n    node: {\n      children: treeData,\n      expanded: true\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: [],\n    isPseudoRoot: true\n  })\n\n  if (result.node) {\n    return result\n  }\n\n  return null\n}\n\n/**\n * Walk descendants depth-first and call a callback on each\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return void\n */\nexport function walk({\n  treeData,\n  getNodeKey,\n  callback,\n  ignoreCollapsed = true\n}) {\n  if (!treeData || treeData.length < 1) {\n    return\n  }\n\n  walkDescendants({\n    callback,\n    getNodeKey,\n    ignoreCollapsed,\n    isPseudoRoot: true,\n    node: { children: treeData },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  })\n}\n\n/**\n * Perform a depth-first transversal of the descendants and\n *  make a change to every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function map({\n  treeData,\n  getNodeKey,\n  callback,\n  ignoreCollapsed = true\n}) {\n  if (!treeData || treeData.length < 1) {\n    return []\n  }\n\n  return mapDescendants({\n    callback,\n    getNodeKey,\n    ignoreCollapsed,\n    isPseudoRoot: true,\n    node: { children: treeData },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  }).node.children\n}\n\n/**\n * Expand or close every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {?boolean} expanded - Whether the node is expanded or not\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function toggleExpandedForAll({ treeData, expanded = true }) {\n  return map({\n    treeData,\n    callback: ({ node }) => ({ ...node, expanded }),\n    getNodeKey: ({ treeIndex }) => treeIndex,\n    ignoreCollapsed: false\n  })\n}\n\n/**\n * Replaces node at path with object, or callback-defined object\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be changed\n * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function changeNodeAtPath({\n  treeData,\n  path,\n  newNode,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  const RESULT_MISS = 'RESULT_MISS'\n  const traverse = ({\n    isPseudoRoot = false,\n    node,\n    currentTreeIndex,\n    pathIndex\n  }) => {\n    if (\n      !isPseudoRoot &&\n      getNodeKey({ node, treeIndex: currentTreeIndex }) !== path[pathIndex]\n    ) {\n      return RESULT_MISS\n    }\n\n    if (pathIndex >= path.length - 1) {\n      // If this is the final location in the path, return its changed form\n      return typeof newNode === 'function'\n        ? newNode({ node, treeIndex: currentTreeIndex })\n        : newNode\n    }\n    if (!node.children) {\n      // If this node is part of the path, but has no children, return the unchanged node\n      throw new Error('Path referenced children of node with no children.')\n    }\n\n    let nextTreeIndex = currentTreeIndex + 1\n    for (let i = 0; i < node.children.length; i += 1) {\n      const result = traverse({\n        node: node.children[i],\n        currentTreeIndex: nextTreeIndex,\n        pathIndex: pathIndex + 1\n      })\n\n      // If the result went down the correct path\n      if (result !== RESULT_MISS) {\n        if (result) {\n          // If the result was truthy (in this case, an object),\n          //  pass it to the next level of recursion up\n          return {\n            ...node,\n            children: [\n              ...node.children.slice(0, i),\n              result,\n              ...node.children.slice(i + 1)\n            ]\n          }\n        }\n        // If the result was falsy (returned from the newNode function), then\n        //  delete the node from the array.\n        return {\n          ...node,\n          children: [\n            ...node.children.slice(0, i),\n            ...node.children.slice(i + 1)\n          ]\n        }\n      }\n\n      nextTreeIndex +=\n        1 + getDescendantCount({ node: node.children[i], ignoreCollapsed })\n    }\n\n    return RESULT_MISS\n  }\n\n  // Use a pseudo-root node in the beginning traversal\n  const result = traverse({\n    node: { children: treeData },\n    currentTreeIndex: -1,\n    pathIndex: -1,\n    isPseudoRoot: true\n  })\n\n  if (result === RESULT_MISS) {\n    throw new Error('No node found at the given path.')\n  }\n\n  return result.children\n}\n\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The tree data with the node removed\n */\nexport function removeNodeAtPath({\n  treeData,\n  path,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  return changeNodeAtPath({\n    treeData,\n    path,\n    getNodeKey,\n    ignoreCollapsed,\n    newNode: null // Delete the node\n  })\n}\n\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node removed\n * @return {Object} result.node - The node that was removed\n * @return {number} result.treeIndex - The previous treeIndex of the removed node\n */\nexport function removeNode({\n  treeData,\n  path,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  let removedNode = null\n  let removedTreeIndex = null\n  const nextTreeData = changeNodeAtPath({\n    treeData,\n    path,\n    getNodeKey,\n    ignoreCollapsed,\n    newNode: ({ node, treeIndex }) => {\n      // Store the target node and delete it from the tree\n      removedNode = node\n      removedTreeIndex = treeIndex\n\n      return null\n    }\n  })\n\n  return {\n    treeData: nextTreeData,\n    node: removedNode,\n    treeIndex: removedTreeIndex\n  }\n}\n\n/**\n * Gets the node at the specified path\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\n */\nexport function getNodeAtPath({\n  treeData,\n  path,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  let foundNodeInfo = null\n\n  try {\n    changeNodeAtPath({\n      treeData,\n      path,\n      getNodeKey,\n      ignoreCollapsed,\n      newNode: ({ node, treeIndex }) => {\n        foundNodeInfo = { node, treeIndex }\n        return node\n      }\n    })\n  } catch (err) {\n    // Ignore the error -- the null return will be explanation enough\n  }\n\n  return foundNodeInfo\n}\n\n/**\n * Adds the node to the specified parent and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {!Object} newNode - The node to insert\n * @param {number|string} parentKey - The key of the to-be parentNode of the node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\n * @param {boolean=} addAsFirstChild - If true, adds new node as first child of tree\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The updated tree data\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n */\nexport function addNodeUnderParent({\n  treeData,\n  newNode,\n  parentKey = null,\n  getNodeKey,\n  ignoreCollapsed = true,\n  expandParent = false,\n  addAsFirstChild = false\n}) {\n  if (parentKey === null) {\n    return addAsFirstChild\n      ? {\n          treeData: [newNode, ...(treeData || [])],\n          treeIndex: 0\n        }\n      : {\n          treeData: [...(treeData || []), newNode],\n          treeIndex: (treeData || []).length\n        }\n  }\n\n  let insertedTreeIndex = null\n  let hasBeenAdded = false\n  const changedTreeData = map({\n    treeData,\n    getNodeKey,\n    ignoreCollapsed,\n    callback: ({ node, treeIndex, path }) => {\n      const key = path ? path[path.length - 1] : null\n      // Return nodes that are not the parent as-is\n      if (hasBeenAdded || key !== parentKey) {\n        return node\n      }\n      hasBeenAdded = true\n\n      const parentNode = {\n        ...node\n      }\n\n      if (expandParent) {\n        parentNode.expanded = true\n      }\n\n      // If no children exist yet, just add the single newNode\n      if (!parentNode.children) {\n        insertedTreeIndex = treeIndex + 1\n        return {\n          ...parentNode,\n          children: [newNode]\n        }\n      }\n\n      if (typeof parentNode.children === 'function') {\n        throw new Error('Cannot add to children defined by a function')\n      }\n\n      let nextTreeIndex = treeIndex + 1\n      for (let i = 0; i < parentNode.children.length; i += 1) {\n        nextTreeIndex +=\n          1 +\n          getDescendantCount({ node: parentNode.children[i], ignoreCollapsed })\n      }\n\n      insertedTreeIndex = nextTreeIndex\n\n      const children = addAsFirstChild\n        ? [newNode, ...parentNode.children]\n        : [...parentNode.children, newNode]\n\n      return {\n        ...parentNode,\n        children\n      }\n    }\n  })\n\n  if (!hasBeenAdded) {\n    throw new Error('No node found with the given key.')\n  }\n\n  return {\n    treeData: changedTreeData,\n    treeIndex: insertedTreeIndex\n  }\n}\n\nfunction addNodeAtDepthAndIndex({\n  targetDepth,\n  minimumTreeIndex,\n  newNode,\n  ignoreCollapsed,\n  expandParent,\n  isPseudoRoot = false,\n  isLastChild,\n  node,\n  currentIndex,\n  currentDepth,\n  getNodeKey,\n  path = []\n}) {\n  const selfPath = (n) =>\n    isPseudoRoot\n      ? []\n      : [...path, getNodeKey({ node: n, treeIndex: currentIndex })]\n\n  // If the current position is the only possible place to add, add it\n  if (\n    currentIndex >= minimumTreeIndex - 1 ||\n    (isLastChild && !(node.children && node.children.length))\n  ) {\n    if (typeof node.children === 'function') {\n      throw new Error('Cannot add to children defined by a function')\n    } else {\n      const extraNodeProps = expandParent ? { expanded: true } : {}\n      const nextNode = {\n        ...node,\n\n        ...extraNodeProps,\n        children: node.children ? [newNode, ...node.children] : [newNode]\n      }\n\n      return {\n        node: nextNode,\n        nextIndex: currentIndex + 2,\n        insertedTreeIndex: currentIndex + 1,\n        parentPath: selfPath(nextNode),\n        parentNode: isPseudoRoot ? null : nextNode\n      }\n    }\n  }\n\n  // If this is the target depth for the insertion,\n  // i.e., where the newNode can be added to the current node's children\n  if (currentDepth >= targetDepth - 1) {\n    // Skip over nodes with no children or hidden children\n    if (\n      !node.children ||\n      typeof node.children === 'function' ||\n      (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n    ) {\n      return { node, nextIndex: currentIndex + 1 }\n    }\n\n    // Scan over the children to see if there's a place among them that fulfills\n    // the minimumTreeIndex requirement\n    let childIndex = currentIndex + 1\n    let insertedTreeIndex = null\n    let insertIndex = null\n    for (let i = 0; i < node.children.length; i += 1) {\n      // If a valid location is found, mark it as the insertion location and\n      // break out of the loop\n      if (childIndex >= minimumTreeIndex) {\n        insertedTreeIndex = childIndex\n        insertIndex = i\n        break\n      }\n\n      // Increment the index by the child itself plus the number of descendants it has\n      childIndex +=\n        1 + getDescendantCount({ node: node.children[i], ignoreCollapsed })\n    }\n\n    // If no valid indices to add the node were found\n    if (insertIndex === null) {\n      // If the last position in this node's children is less than the minimum index\n      // and there are more children on the level of this node, return without insertion\n      if (childIndex < minimumTreeIndex && !isLastChild) {\n        return { node, nextIndex: childIndex }\n      }\n\n      // Use the last position in the children array to insert the newNode\n      insertedTreeIndex = childIndex\n      insertIndex = node.children.length\n    }\n\n    // Insert the newNode at the insertIndex\n    const nextNode = {\n      ...node,\n      children: [\n        ...node.children.slice(0, insertIndex),\n        newNode,\n        ...node.children.slice(insertIndex)\n      ]\n    }\n\n    // Return node with successful insert result\n    return {\n      node: nextNode,\n      nextIndex: childIndex,\n      insertedTreeIndex,\n      parentPath: selfPath(nextNode),\n      parentNode: isPseudoRoot ? null : nextNode\n    }\n  }\n\n  // Skip over nodes with no children or hidden children\n  if (\n    !node.children ||\n    typeof node.children === 'function' ||\n    (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n  ) {\n    return { node, nextIndex: currentIndex + 1 }\n  }\n\n  // Get all descendants\n  let insertedTreeIndex = null\n  let pathFragment = null\n  let parentNode = null\n  let childIndex = currentIndex + 1\n  let newChildren = node.children\n  if (typeof newChildren !== 'function') {\n    newChildren = newChildren.map((child, i) => {\n      if (insertedTreeIndex !== null) {\n        return child\n      }\n\n      const mapResult = addNodeAtDepthAndIndex({\n        targetDepth,\n        minimumTreeIndex,\n        newNode,\n        ignoreCollapsed,\n        expandParent,\n        isLastChild: isLastChild && i === newChildren.length - 1,\n        node: child,\n        currentIndex: childIndex,\n        currentDepth: currentDepth + 1,\n        getNodeKey,\n        path: [] // Cannot determine the parent path until the children have been processed\n      })\n\n      if ('insertedTreeIndex' in mapResult) {\n        ;({\n          insertedTreeIndex,\n          parentNode,\n          parentPath: pathFragment\n        } = mapResult)\n      }\n\n      childIndex = mapResult.nextIndex\n\n      return mapResult.node\n    })\n  }\n\n  const nextNode = { ...node, children: newChildren }\n  const result = {\n    node: nextNode,\n    nextIndex: childIndex\n  }\n\n  if (insertedTreeIndex !== null) {\n    result.insertedTreeIndex = insertedTreeIndex\n    result.parentPath = [...selfPath(nextNode), ...pathFragment]\n    result.parentNode = parentNode\n  }\n\n  return result\n}\n\n/**\n * Insert a node into the tree at the given depth, after the minimum index\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} depth - The depth to insert the node at (the first level of the array being depth 0)\n * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\n * @param {!Object} newNode - The node to insert into the tree\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parent of the inserted node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node added\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\n * @return {Object} result.parentNode - The parent node of the inserted node\n */\nexport function insertNode({\n  treeData,\n  depth: targetDepth,\n  minimumTreeIndex,\n  newNode,\n  getNodeKey = () => {},\n  ignoreCollapsed = true,\n  expandParent = false\n}) {\n  if (!treeData && targetDepth === 0) {\n    return {\n      treeData: [newNode],\n      treeIndex: 0,\n      path: [getNodeKey({ node: newNode, treeIndex: 0 })],\n      parentNode: null\n    }\n  }\n\n  const insertResult = addNodeAtDepthAndIndex({\n    targetDepth,\n    minimumTreeIndex,\n    newNode,\n    ignoreCollapsed,\n    expandParent,\n    getNodeKey,\n    isPseudoRoot: true,\n    isLastChild: true,\n    node: { children: treeData },\n    currentIndex: -1,\n    currentDepth: -1\n  })\n\n  if (!('insertedTreeIndex' in insertResult)) {\n    throw new Error('No suitable position found to insert.')\n  }\n\n  const treeIndex = insertResult.insertedTreeIndex\n  return {\n    treeData: insertResult.node.children,\n    treeIndex,\n    path: [\n      ...insertResult.parentPath,\n      getNodeKey({ node: newNode, treeIndex })\n    ],\n    parentNode: insertResult.parentNode\n  }\n}\n\n/**\n * Get tree data flattened.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }}[] nodes - The node array\n */\nexport function getFlatDataFromTree({\n  treeData,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  if (!treeData || treeData.length < 1) {\n    return []\n  }\n\n  const flattened = []\n  walk({\n    treeData,\n    getNodeKey,\n    ignoreCollapsed,\n    callback: (nodeInfo) => {\n      flattened.push(nodeInfo)\n    }\n  })\n\n  return flattened\n}\n\n/**\n * Generate a tree structure from flat data.\n *\n * @param {!Object[]} flatData\n * @param {!function=} getKey - Function to get the key from the nodeData\n * @param {!function=} getParentKey - Function to get the parent key from the nodeData\n * @param {string|number=} rootKey - The value returned by `getParentKey` that corresponds to the root node.\n *                                  For example, if your nodes have id 1-99, you might use rootKey = 0\n *\n * @return {Object[]} treeData - The flat data represented as a tree\n */\nexport function getTreeFromFlatData({\n  flatData,\n  getKey = (node) => node.id,\n  getParentKey = (node) => node.parentId,\n  rootKey = '0'\n}) {\n  if (!flatData) {\n    return []\n  }\n\n  const childrenToParents = {}\n  flatData.forEach((child) => {\n    const parentKey = getParentKey(child)\n\n    if (parentKey in childrenToParents) {\n      childrenToParents[parentKey].push(child)\n    } else {\n      childrenToParents[parentKey] = [child]\n    }\n  })\n\n  if (!(rootKey in childrenToParents)) {\n    return []\n  }\n\n  const trav = (parent) => {\n    const parentKey = getKey(parent)\n    if (parentKey in childrenToParents) {\n      return {\n        ...parent,\n        children: childrenToParents[parentKey].map((child) => trav(child))\n      }\n    }\n\n    return { ...parent }\n  }\n\n  return childrenToParents[rootKey].map((child) => trav(child))\n}\n\n/**\n * Check if a node is a descendant of another node.\n *\n * @param {!Object} older - Potential ancestor of younger node\n * @param {!Object} younger - Potential descendant of older node\n *\n * @return {boolean}\n */\nexport function isDescendant(older, younger) {\n  return (\n    !!older.children &&\n    typeof older.children !== 'function' &&\n    older.children.some(\n      (child) => child === younger || isDescendant(child, younger)\n    )\n  )\n}\n\n/**\n * Get the maximum depth of the children (the depth of the root node is 0).\n *\n * @param {!Object} node - Node in the tree\n * @param {?number} depth - The current depth\n *\n * @return {number} maxDepth - The deepest depth in the tree\n */\nexport function getDepth(node, depth = 0) {\n  if (!node.children) {\n    return depth\n  }\n\n  if (typeof node.children === 'function') {\n    return depth + 1\n  }\n\n  return node.children.reduce(\n    (deepest, child) => Math.max(deepest, getDepth(child, depth + 1)),\n    depth\n  )\n}\n\n/**\n * Find nodes matching a search query in the tree,\n *\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {!Object[]} treeData - Tree data\n * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\n * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\n * @param {?number} searchFocusOffset - The offset of the match to focus on\n *                                      (e.g., 0 focuses on the first match, 1 on the second)\n * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\n * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\n *\n * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\n * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\n *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\n *                               it will be the same as the original tree data.\n */\nexport function find({\n  getNodeKey,\n  treeData,\n  searchQuery,\n  searchMethod,\n  searchFocusOffset,\n  expandAllMatchPaths = false,\n  expandFocusMatchPaths = true\n}) {\n  let matchCount = 0\n  const trav = ({ isPseudoRoot = false, node, currentIndex, path = [] }) => {\n    let matches = []\n    let isSelfMatch = false\n    let hasFocusMatch = false\n    // The pseudo-root is not considered in the path\n    const selfPath = isPseudoRoot\n      ? []\n      : [...path, getNodeKey({ node, treeIndex: currentIndex })]\n    const extraInfo = isPseudoRoot\n      ? null\n      : {\n          path: selfPath,\n          treeIndex: currentIndex\n        }\n\n    // Nodes with with children that aren't lazy\n    const hasChildren =\n      node.children &&\n      typeof node.children !== 'function' &&\n      node.children.length > 0\n\n    // Examine the current node to see if it is a match\n    if (!isPseudoRoot && searchMethod({ ...extraInfo, node, searchQuery })) {\n      if (matchCount === searchFocusOffset) {\n        hasFocusMatch = true\n      }\n\n      // Keep track of the number of matching nodes, so we know when the searchFocusOffset\n      //  is reached\n      matchCount += 1\n\n      // We cannot add this node to the matches right away, as it may be changed\n      //  during the search of the descendants. The entire node is used in\n      //  comparisons between nodes inside the `matches` and `treeData` results\n      //  of this method (`find`)\n      isSelfMatch = true\n    }\n\n    let childIndex = currentIndex\n    const newNode = { ...node }\n    if (hasChildren) {\n      // Get all descendants\n      newNode.children = newNode.children.map((child) => {\n        const mapResult = trav({\n          node: child,\n          currentIndex: childIndex + 1,\n          path: selfPath\n        })\n\n        // Ignore hidden nodes by only advancing the index counter to the returned treeIndex\n        // if the child is expanded.\n        //\n        // The child could have been expanded from the start,\n        // or expanded due to a matching node being found in its descendants\n        if (mapResult.node.expanded) {\n          childIndex = mapResult.treeIndex\n        } else {\n          childIndex += 1\n        }\n\n        if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {\n          matches = [...matches, ...mapResult.matches]\n          if (mapResult.hasFocusMatch) {\n            hasFocusMatch = true\n          }\n\n          // Expand the current node if it has descendants matching the search\n          // and the settings are set to do so.\n          if (\n            (expandAllMatchPaths && mapResult.matches.length > 0) ||\n            ((expandAllMatchPaths || expandFocusMatchPaths) &&\n              mapResult.hasFocusMatch)\n          ) {\n            newNode.expanded = true\n          }\n        }\n\n        return mapResult.node\n      })\n    }\n\n    // Cannot assign a treeIndex to hidden nodes\n    if (!isPseudoRoot && !newNode.expanded) {\n      matches = matches.map((match) => ({\n        ...match,\n        treeIndex: null\n      }))\n    }\n\n    // Add this node to the matches if it fits the search criteria.\n    // This is performed at the last minute so newNode can be sent in its final form.\n    if (isSelfMatch) {\n      matches = [{ ...extraInfo, node: newNode }, ...matches]\n    }\n\n    return {\n      node: matches.length > 0 ? newNode : node,\n      matches,\n      hasFocusMatch,\n      treeIndex: childIndex\n    }\n  }\n\n  const result = trav({\n    node: { children: treeData },\n    isPseudoRoot: true,\n    currentIndex: -1\n  })\n\n  return {\n    matches: result.matches,\n    treeData: result.node.children\n  }\n}\n"],"names":["getNodeDataAtTreeIndexOrNextIndex","_ref","targetIndex","node","currentIndex","getNodeKey","_ref$path","path","_ref$lowerSiblingCoun","lowerSiblingCounts","_ref$ignoreCollapsed","ignoreCollapsed","_ref$isPseudoRoot","isPseudoRoot","selfPath","treeIndex","children","expanded","nextIndex","childIndex","childCount","length","i","result","concat","_toConsumableArray","getDescendantCount","_ref2","_ref2$ignoreCollapsed","walkDescendants","_ref3","callback","_ref3$isPseudoRoot","_ref3$parentNode","parentNode","_ref3$path","_ref3$lowerSiblingCou","mapDescendants","_ref4","_ref4$isPseudoRoot","_ref4$parentNode","_ref4$path","_ref4$lowerSiblingCou","nextNode","selfInfo","map","child","mapResult","walk","_ref7","treeData","_ref7$ignoreCollapsed","_ref8","_ref8$ignoreCollapsed","changeNodeAtPath","_ref12","newNode","_ref12$ignoreCollapse","RESULT_MISS","traverse","_ref13","_ref13$isPseudoRoot","currentTreeIndex","pathIndex","Error","nextTreeIndex","_objectSpread","_objectSpread2","slice","addNodeAtDepthAndIndex","_ref21","targetDepth","minimumTreeIndex","expandParent","_ref21$isPseudoRoot","isLastChild","currentDepth","_ref21$path","n","extraNodeProps","insertedTreeIndex","parentPath","insertIndex","pathFragment","newChildren","_ref19","_ref19$parentKey","parentKey","_ref19$ignoreCollapse","_ref19$expandParent","_ref19$addAsFirstChil","addAsFirstChild","hasBeenAdded","changedTreeData","_ref20","key","_ref25","searchQuery","searchMethod","searchFocusOffset","_ref25$expandAllMatch","expandAllMatchPaths","_ref25$expandFocusMat","expandFocusMatchPaths","matchCount","trav","_ref26","_ref26$isPseudoRoot","_ref26$path","matches","isSelfMatch","hasFocusMatch","extraInfo","hasChildren","match","getDepth","depth","reduce","deepest","Math","max","_ref23","_ref23$ignoreCollapse","flattened","nodeInfo","push","_ref17","_ref17$ignoreCollapse","foundNodeInfo","_ref18","err","_ref24","flatData","_ref24$getKey","getKey","id","_ref24$getParentKey","getParentKey","parentId","_ref24$rootKey","rootKey","childrenToParents","forEach","parent","_ref5","total","currentNode","_ref6","index","_ref22","_ref22$getNodeKey","_ref22$ignoreCollapse","_ref22$expandParent","insertResult","isDescendant","older","younger","some","_ref15","_ref15$ignoreCollapse","removedNode","removedTreeIndex","_ref16","_ref14","_ref14$ignoreCollapse","_ref9","_ref9$expanded","_ref10","_ref11"],"mappings":"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"}