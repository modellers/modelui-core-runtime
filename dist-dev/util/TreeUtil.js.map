{"version":3,"file":"TreeUtil.js","sources":["../../src/util/TreeUtil.js"],"sourcesContent":["// copied as is from\n// https://github.com/frontend-collective/react-sortable-tree/blob/master/src/utils/tree-data-utils.js\n\n/**\n * Performs a depth-first traversal over all of the node descendants,\n * incrementing currentIndex by 1 for each\n */\nfunction getNodeDataAtTreeIndexOrNextIndex({\n  targetIndex,\n  node,\n  currentIndex,\n  getNodeKey,\n  path = [],\n  lowerSiblingCounts = [],\n  ignoreCollapsed = true,\n  isPseudoRoot = false\n}) {\n  // The pseudo-root is not considered in the path\n  const selfPath = !isPseudoRoot\n    ? [...path, getNodeKey({ node, treeIndex: currentIndex })]\n    : []\n\n  // Return target node when found\n  if (currentIndex === targetIndex) {\n    return {\n      node,\n      lowerSiblingCounts,\n      path: selfPath\n    }\n  }\n\n  // Add one and continue for nodes with no children or hidden children\n  if (!node.children || (ignoreCollapsed && node.expanded !== true)) {\n    return { nextIndex: currentIndex + 1 }\n  }\n\n  // Iterate over each child and their descendants and return the\n  // target node if childIndex reaches the targetIndex\n  let childIndex = currentIndex + 1\n  const childCount = node.children.length\n  for (let i = 0; i < childCount; i += 1) {\n    const result = getNodeDataAtTreeIndexOrNextIndex({\n      ignoreCollapsed,\n      getNodeKey,\n      targetIndex,\n      node: node.children[i],\n      currentIndex: childIndex,\n      lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\n      path: selfPath\n    })\n\n    if (result.node) {\n      return result\n    }\n\n    childIndex = result.nextIndex\n  }\n\n  // If the target node is not found, return the farthest traversed index\n  return { nextIndex: childIndex }\n}\n\nexport function getDescendantCount({ node, ignoreCollapsed = true }) {\n  return (\n    getNodeDataAtTreeIndexOrNextIndex({\n      getNodeKey: () => {},\n      ignoreCollapsed,\n      node,\n      currentIndex: 0,\n      targetIndex: -1\n    }).nextIndex - 1\n  )\n}\n\n/**\n * Walk all descendants of the given node, depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\nfunction walkDescendants({\n  callback,\n  getNodeKey,\n  ignoreCollapsed,\n  isPseudoRoot = false,\n  node,\n  parentNode = null,\n  currentIndex,\n  path = [],\n  lowerSiblingCounts = []\n}) {\n  // The pseudo-root is not considered in the path\n  const selfPath = isPseudoRoot\n    ? []\n    : [...path, getNodeKey({ node, treeIndex: currentIndex })]\n  const selfInfo = isPseudoRoot\n    ? null\n    : {\n        node,\n        parentNode,\n        path: selfPath,\n        lowerSiblingCounts,\n        treeIndex: currentIndex\n      }\n\n  if (!isPseudoRoot) {\n    const callbackResult = callback(selfInfo)\n\n    // Cut walk short if the callback returned false\n    if (callbackResult === false) {\n      return false\n    }\n  }\n\n  // Return self on nodes with no children or hidden children\n  if (\n    !node.children ||\n    (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n  ) {\n    return currentIndex\n  }\n\n  // Get all descendants\n  let childIndex = currentIndex\n  const childCount = node.children.length\n  if (typeof node.children !== 'function') {\n    for (let i = 0; i < childCount; i += 1) {\n      childIndex = walkDescendants({\n        callback,\n        getNodeKey,\n        ignoreCollapsed,\n        node: node.children[i],\n        parentNode: isPseudoRoot ? null : node,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\n        path: selfPath\n      })\n\n      // Cut walk short if the callback returned false\n      if (childIndex === false) {\n        return false\n      }\n    }\n  }\n\n  return childIndex\n}\n\n/**\n * Perform a change on the given node and all its descendants, traversing the tree depth-first\n *\n * @param {Object} args - Function parameters\n * @param {function} args.callback - Function to call on each node\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\n *                                        as the parent of all the nodes in the tree\n * @param {Object} args.node - A tree node\n * @param {Object=} args.parentNode - The parent node of `node`\n * @param {number} args.currentIndex - The treeIndex of `node`\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\n *                                             previous nodes in this path\n *\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\n *                                    or false if the walk should be terminated\n */\nfunction mapDescendants({\n  callback,\n  getNodeKey,\n  ignoreCollapsed,\n  isPseudoRoot = false,\n  node,\n  parentNode = null,\n  currentIndex,\n  path = [],\n  lowerSiblingCounts = []\n}) {\n  const nextNode = { ...node }\n\n  // The pseudo-root is not considered in the path\n  const selfPath = isPseudoRoot\n    ? []\n    : [...path, getNodeKey({ node: nextNode, treeIndex: currentIndex })]\n  const selfInfo = {\n    node: nextNode,\n    parentNode,\n    path: selfPath,\n    lowerSiblingCounts,\n    treeIndex: currentIndex\n  }\n\n  // Return self on nodes with no children or hidden children\n  if (\n    !nextNode.children ||\n    (nextNode.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n  ) {\n    return {\n      treeIndex: currentIndex,\n      node: callback(selfInfo)\n    }\n  }\n\n  // Get all descendants\n  let childIndex = currentIndex\n  const childCount = nextNode.children.length\n  if (typeof nextNode.children !== 'function') {\n    nextNode.children = nextNode.children.map((child, i) => {\n      const mapResult = mapDescendants({\n        callback,\n        getNodeKey,\n        ignoreCollapsed,\n        node: child,\n        parentNode: isPseudoRoot ? null : nextNode,\n        currentIndex: childIndex + 1,\n        lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\n        path: selfPath\n      })\n      childIndex = mapResult.treeIndex\n\n      return mapResult.node\n    })\n  }\n\n  return {\n    node: callback(selfInfo),\n    treeIndex: childIndex\n  }\n}\n\n/**\n * Count all the visible (expanded) descendants in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n *\n * @return {number} count\n */\nexport function getVisibleNodeCount({ treeData }) {\n  const traverse = (node) => {\n    if (\n      !node.children ||\n      node.expanded !== true ||\n      typeof node.children === 'function'\n    ) {\n      return 1\n    }\n\n    return (\n      1 +\n      node.children.reduce(\n        (total, currentNode) => total + traverse(currentNode),\n        0\n      )\n    )\n  }\n\n  return treeData.reduce(\n    (total, currentNode) => total + traverse(currentNode),\n    0\n  )\n}\n\n/**\n * Get the <targetIndex>th visible node in the tree data.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} targetIndex - The index of the node to search for\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }|null} node - The node at targetIndex, or null if not found\n */\nexport function getVisibleNodeInfoAtIndex({\n  treeData,\n  index: targetIndex,\n  getNodeKey\n}) {\n  if (!treeData || treeData.length < 1) {\n    return null\n  }\n\n  // Call the tree traversal with a pseudo-root node\n  const result = getNodeDataAtTreeIndexOrNextIndex({\n    targetIndex,\n    getNodeKey,\n    node: {\n      children: treeData,\n      expanded: true\n    },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: [],\n    isPseudoRoot: true\n  })\n\n  if (result.node) {\n    return result\n  }\n\n  return null\n}\n\n/**\n * Walk descendants depth-first and call a callback on each\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return void\n */\nexport function walk({\n  treeData,\n  getNodeKey,\n  callback,\n  ignoreCollapsed = true\n}) {\n  if (!treeData || treeData.length < 1) {\n    return\n  }\n\n  walkDescendants({\n    callback,\n    getNodeKey,\n    ignoreCollapsed,\n    isPseudoRoot: true,\n    node: { children: treeData },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  })\n}\n\n/**\n * Perform a depth-first transversal of the descendants and\n *  make a change to every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {function} callback - Function to call on each node\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function map({\n  treeData,\n  getNodeKey,\n  callback,\n  ignoreCollapsed = true\n}) {\n  if (!treeData || treeData.length < 1) {\n    return []\n  }\n\n  return mapDescendants({\n    callback,\n    getNodeKey,\n    ignoreCollapsed,\n    isPseudoRoot: true,\n    node: { children: treeData },\n    currentIndex: -1,\n    path: [],\n    lowerSiblingCounts: []\n  }).node.children\n}\n\n/**\n * Expand or close every node in the tree\n *\n * @param {!Object[]} treeData - Tree data\n * @param {?boolean} expanded - Whether the node is expanded or not\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function toggleExpandedForAll({ treeData, expanded = true }) {\n  return map({\n    treeData,\n    callback: ({ node }) => ({ ...node, expanded }),\n    getNodeKey: ({ treeIndex }) => treeIndex,\n    ignoreCollapsed: false\n  })\n}\n\n/**\n * Replaces node at path with object, or callback-defined object\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be changed\n * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The changed tree data\n */\nexport function changeNodeAtPath({\n  treeData,\n  path,\n  newNode,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  const RESULT_MISS = 'RESULT_MISS'\n  const traverse = ({\n    isPseudoRoot = false,\n    node,\n    currentTreeIndex,\n    pathIndex\n  }) => {\n    if (\n      !isPseudoRoot &&\n      getNodeKey({ node, treeIndex: currentTreeIndex }) !== path[pathIndex]\n    ) {\n      return RESULT_MISS\n    }\n\n    if (pathIndex >= path.length - 1) {\n      // If this is the final location in the path, return its changed form\n      return typeof newNode === 'function'\n        ? newNode({ node, treeIndex: currentTreeIndex })\n        : newNode\n    }\n    if (!node.children) {\n      // If this node is part of the path, but has no children, return the unchanged node\n      throw new Error('Path referenced children of node with no children.')\n    }\n\n    let nextTreeIndex = currentTreeIndex + 1\n    for (let i = 0; i < node.children.length; i += 1) {\n      const result = traverse({\n        node: node.children[i],\n        currentTreeIndex: nextTreeIndex,\n        pathIndex: pathIndex + 1\n      })\n\n      // If the result went down the correct path\n      if (result !== RESULT_MISS) {\n        if (result) {\n          // If the result was truthy (in this case, an object),\n          //  pass it to the next level of recursion up\n          return {\n            ...node,\n            children: [\n              ...node.children.slice(0, i),\n              result,\n              ...node.children.slice(i + 1)\n            ]\n          }\n        }\n        // If the result was falsy (returned from the newNode function), then\n        //  delete the node from the array.\n        return {\n          ...node,\n          children: [\n            ...node.children.slice(0, i),\n            ...node.children.slice(i + 1)\n          ]\n        }\n      }\n\n      nextTreeIndex +=\n        1 + getDescendantCount({ node: node.children[i], ignoreCollapsed })\n    }\n\n    return RESULT_MISS\n  }\n\n  // Use a pseudo-root node in the beginning traversal\n  const result = traverse({\n    node: { children: treeData },\n    currentTreeIndex: -1,\n    pathIndex: -1,\n    isPseudoRoot: true\n  })\n\n  if (result === RESULT_MISS) {\n    throw new Error('No node found at the given path.')\n  }\n\n  return result.children\n}\n\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object[]} changedTreeData - The tree data with the node removed\n */\nexport function removeNodeAtPath({\n  treeData,\n  path,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  return changeNodeAtPath({\n    treeData,\n    path,\n    getNodeKey,\n    ignoreCollapsed,\n    newNode: null // Delete the node\n  })\n}\n\n/**\n * Removes the node at the specified path and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node removed\n * @return {Object} result.node - The node that was removed\n * @return {number} result.treeIndex - The previous treeIndex of the removed node\n */\nexport function removeNode({\n  treeData,\n  path,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  let removedNode = null\n  let removedTreeIndex = null\n  const nextTreeData = changeNodeAtPath({\n    treeData,\n    path,\n    getNodeKey,\n    ignoreCollapsed,\n    newNode: ({ node, treeIndex }) => {\n      // Store the target node and delete it from the tree\n      removedNode = node\n      removedTreeIndex = treeIndex\n\n      return null\n    }\n  })\n\n  return {\n    treeData: nextTreeData,\n    node: removedNode,\n    treeIndex: removedTreeIndex\n  }\n}\n\n/**\n * Gets the node at the specified path\n *\n * @param {!Object[]} treeData\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\n */\nexport function getNodeAtPath({\n  treeData,\n  path,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  let foundNodeInfo = null\n\n  try {\n    changeNodeAtPath({\n      treeData,\n      path,\n      getNodeKey,\n      ignoreCollapsed,\n      newNode: ({ node, treeIndex }) => {\n        foundNodeInfo = { node, treeIndex }\n        return node\n      }\n    })\n  } catch (err) {\n    // Ignore the error -- the null return will be explanation enough\n  }\n\n  return foundNodeInfo\n}\n\n/**\n * Adds the node to the specified parent and returns the resulting treeData.\n *\n * @param {!Object[]} treeData\n * @param {!Object} newNode - The node to insert\n * @param {number|string} parentKey - The key of the to-be parentNode of the node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\n * @param {boolean=} addAsFirstChild - If true, adds new node as first child of tree\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The updated tree data\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n */\nexport function addNodeUnderParent({\n  treeData,\n  newNode,\n  parentKey = null,\n  getNodeKey,\n  ignoreCollapsed = true,\n  expandParent = false,\n  addAsFirstChild = false\n}) {\n  if (parentKey === null) {\n    return addAsFirstChild\n      ? {\n          treeData: [newNode, ...(treeData || [])],\n          treeIndex: 0\n        }\n      : {\n          treeData: [...(treeData || []), newNode],\n          treeIndex: (treeData || []).length\n        }\n  }\n\n  let insertedTreeIndex = null\n  let hasBeenAdded = false\n  const changedTreeData = map({\n    treeData,\n    getNodeKey,\n    ignoreCollapsed,\n    callback: ({ node, treeIndex, path }) => {\n      const key = path ? path[path.length - 1] : null\n      // Return nodes that are not the parent as-is\n      if (hasBeenAdded || key !== parentKey) {\n        return node\n      }\n      hasBeenAdded = true\n\n      const parentNode = {\n        ...node\n      }\n\n      if (expandParent) {\n        parentNode.expanded = true\n      }\n\n      // If no children exist yet, just add the single newNode\n      if (!parentNode.children) {\n        insertedTreeIndex = treeIndex + 1\n        return {\n          ...parentNode,\n          children: [newNode]\n        }\n      }\n\n      if (typeof parentNode.children === 'function') {\n        throw new Error('Cannot add to children defined by a function')\n      }\n\n      let nextTreeIndex = treeIndex + 1\n      for (let i = 0; i < parentNode.children.length; i += 1) {\n        nextTreeIndex +=\n          1 +\n          getDescendantCount({ node: parentNode.children[i], ignoreCollapsed })\n      }\n\n      insertedTreeIndex = nextTreeIndex\n\n      const children = addAsFirstChild\n        ? [newNode, ...parentNode.children]\n        : [...parentNode.children, newNode]\n\n      return {\n        ...parentNode,\n        children\n      }\n    }\n  })\n\n  if (!hasBeenAdded) {\n    throw new Error('No node found with the given key.')\n  }\n\n  return {\n    treeData: changedTreeData,\n    treeIndex: insertedTreeIndex\n  }\n}\n\nfunction addNodeAtDepthAndIndex({\n  targetDepth,\n  minimumTreeIndex,\n  newNode,\n  ignoreCollapsed,\n  expandParent,\n  isPseudoRoot = false,\n  isLastChild,\n  node,\n  currentIndex,\n  currentDepth,\n  getNodeKey,\n  path = []\n}) {\n  const selfPath = (n) =>\n    isPseudoRoot\n      ? []\n      : [...path, getNodeKey({ node: n, treeIndex: currentIndex })]\n\n  // If the current position is the only possible place to add, add it\n  if (\n    currentIndex >= minimumTreeIndex - 1 ||\n    (isLastChild && !(node.children && node.children.length))\n  ) {\n    if (typeof node.children === 'function') {\n      throw new Error('Cannot add to children defined by a function')\n    } else {\n      const extraNodeProps = expandParent ? { expanded: true } : {}\n      const nextNode = {\n        ...node,\n\n        ...extraNodeProps,\n        children: node.children ? [newNode, ...node.children] : [newNode]\n      }\n\n      return {\n        node: nextNode,\n        nextIndex: currentIndex + 2,\n        insertedTreeIndex: currentIndex + 1,\n        parentPath: selfPath(nextNode),\n        parentNode: isPseudoRoot ? null : nextNode\n      }\n    }\n  }\n\n  // If this is the target depth for the insertion,\n  // i.e., where the newNode can be added to the current node's children\n  if (currentDepth >= targetDepth - 1) {\n    // Skip over nodes with no children or hidden children\n    if (\n      !node.children ||\n      typeof node.children === 'function' ||\n      (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n    ) {\n      return { node, nextIndex: currentIndex + 1 }\n    }\n\n    // Scan over the children to see if there's a place among them that fulfills\n    // the minimumTreeIndex requirement\n    let childIndex = currentIndex + 1\n    let insertedTreeIndex = null\n    let insertIndex = null\n    for (let i = 0; i < node.children.length; i += 1) {\n      // If a valid location is found, mark it as the insertion location and\n      // break out of the loop\n      if (childIndex >= minimumTreeIndex) {\n        insertedTreeIndex = childIndex\n        insertIndex = i\n        break\n      }\n\n      // Increment the index by the child itself plus the number of descendants it has\n      childIndex +=\n        1 + getDescendantCount({ node: node.children[i], ignoreCollapsed })\n    }\n\n    // If no valid indices to add the node were found\n    if (insertIndex === null) {\n      // If the last position in this node's children is less than the minimum index\n      // and there are more children on the level of this node, return without insertion\n      if (childIndex < minimumTreeIndex && !isLastChild) {\n        return { node, nextIndex: childIndex }\n      }\n\n      // Use the last position in the children array to insert the newNode\n      insertedTreeIndex = childIndex\n      insertIndex = node.children.length\n    }\n\n    // Insert the newNode at the insertIndex\n    const nextNode = {\n      ...node,\n      children: [\n        ...node.children.slice(0, insertIndex),\n        newNode,\n        ...node.children.slice(insertIndex)\n      ]\n    }\n\n    // Return node with successful insert result\n    return {\n      node: nextNode,\n      nextIndex: childIndex,\n      insertedTreeIndex,\n      parentPath: selfPath(nextNode),\n      parentNode: isPseudoRoot ? null : nextNode\n    }\n  }\n\n  // Skip over nodes with no children or hidden children\n  if (\n    !node.children ||\n    typeof node.children === 'function' ||\n    (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\n  ) {\n    return { node, nextIndex: currentIndex + 1 }\n  }\n\n  // Get all descendants\n  let insertedTreeIndex = null\n  let pathFragment = null\n  let parentNode = null\n  let childIndex = currentIndex + 1\n  let newChildren = node.children\n  if (typeof newChildren !== 'function') {\n    newChildren = newChildren.map((child, i) => {\n      if (insertedTreeIndex !== null) {\n        return child\n      }\n\n      const mapResult = addNodeAtDepthAndIndex({\n        targetDepth,\n        minimumTreeIndex,\n        newNode,\n        ignoreCollapsed,\n        expandParent,\n        isLastChild: isLastChild && i === newChildren.length - 1,\n        node: child,\n        currentIndex: childIndex,\n        currentDepth: currentDepth + 1,\n        getNodeKey,\n        path: [] // Cannot determine the parent path until the children have been processed\n      })\n\n      if ('insertedTreeIndex' in mapResult) {\n        ;({\n          insertedTreeIndex,\n          parentNode,\n          parentPath: pathFragment\n        } = mapResult)\n      }\n\n      childIndex = mapResult.nextIndex\n\n      return mapResult.node\n    })\n  }\n\n  const nextNode = { ...node, children: newChildren }\n  const result = {\n    node: nextNode,\n    nextIndex: childIndex\n  }\n\n  if (insertedTreeIndex !== null) {\n    result.insertedTreeIndex = insertedTreeIndex\n    result.parentPath = [...selfPath(nextNode), ...pathFragment]\n    result.parentNode = parentNode\n  }\n\n  return result\n}\n\n/**\n * Insert a node into the tree at the given depth, after the minimum index\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!number} depth - The depth to insert the node at (the first level of the array being depth 0)\n * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\n * @param {!Object} newNode - The node to insert into the tree\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n * @param {boolean=} expandParent - If true, expands the parent of the inserted node\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n *\n * @return {Object} result\n * @return {Object[]} result.treeData - The tree data with the node added\n * @return {number} result.treeIndex - The tree index at which the node was inserted\n * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\n * @return {Object} result.parentNode - The parent node of the inserted node\n */\nexport function insertNode({\n  treeData,\n  depth: targetDepth,\n  minimumTreeIndex,\n  newNode,\n  getNodeKey = () => {},\n  ignoreCollapsed = true,\n  expandParent = false\n}) {\n  if (!treeData && targetDepth === 0) {\n    return {\n      treeData: [newNode],\n      treeIndex: 0,\n      path: [getNodeKey({ node: newNode, treeIndex: 0 })],\n      parentNode: null\n    }\n  }\n\n  const insertResult = addNodeAtDepthAndIndex({\n    targetDepth,\n    minimumTreeIndex,\n    newNode,\n    ignoreCollapsed,\n    expandParent,\n    getNodeKey,\n    isPseudoRoot: true,\n    isLastChild: true,\n    node: { children: treeData },\n    currentIndex: -1,\n    currentDepth: -1\n  })\n\n  if (!('insertedTreeIndex' in insertResult)) {\n    throw new Error('No suitable position found to insert.')\n  }\n\n  const treeIndex = insertResult.insertedTreeIndex\n  return {\n    treeData: insertResult.node.children,\n    treeIndex,\n    path: [\n      ...insertResult.parentPath,\n      getNodeKey({ node: newNode, treeIndex })\n    ],\n    parentNode: insertResult.parentNode\n  }\n}\n\n/**\n * Get tree data flattened.\n *\n * @param {!Object[]} treeData - Tree data\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\n *\n * @return {{\n *      node: Object,\n *      path: []string|[]number,\n *      lowerSiblingCounts: []number\n *  }}[] nodes - The node array\n */\nexport function getFlatDataFromTree({\n  treeData,\n  getNodeKey,\n  ignoreCollapsed = true\n}) {\n  if (!treeData || treeData.length < 1) {\n    return []\n  }\n\n  const flattened = []\n  walk({\n    treeData,\n    getNodeKey,\n    ignoreCollapsed,\n    callback: (nodeInfo) => {\n      flattened.push(nodeInfo)\n    }\n  })\n\n  return flattened\n}\n\n/**\n * Generate a tree structure from flat data.\n *\n * @param {!Object[]} flatData\n * @param {!function=} getKey - Function to get the key from the nodeData\n * @param {!function=} getParentKey - Function to get the parent key from the nodeData\n * @param {string|number=} rootKey - The value returned by `getParentKey` that corresponds to the root node.\n *                                  For example, if your nodes have id 1-99, you might use rootKey = 0\n *\n * @return {Object[]} treeData - The flat data represented as a tree\n */\nexport function getTreeFromFlatData({\n  flatData,\n  getKey = (node) => node.id,\n  getParentKey = (node) => node.parentId,\n  rootKey = '0'\n}) {\n  if (!flatData) {\n    return []\n  }\n\n  const childrenToParents = {}\n  flatData.forEach((child) => {\n    const parentKey = getParentKey(child)\n\n    if (parentKey in childrenToParents) {\n      childrenToParents[parentKey].push(child)\n    } else {\n      childrenToParents[parentKey] = [child]\n    }\n  })\n\n  if (!(rootKey in childrenToParents)) {\n    return []\n  }\n\n  const trav = (parent) => {\n    const parentKey = getKey(parent)\n    if (parentKey in childrenToParents) {\n      return {\n        ...parent,\n        children: childrenToParents[parentKey].map((child) => trav(child))\n      }\n    }\n\n    return { ...parent }\n  }\n\n  return childrenToParents[rootKey].map((child) => trav(child))\n}\n\n/**\n * Check if a node is a descendant of another node.\n *\n * @param {!Object} older - Potential ancestor of younger node\n * @param {!Object} younger - Potential descendant of older node\n *\n * @return {boolean}\n */\nexport function isDescendant(older, younger) {\n  return (\n    !!older.children &&\n    typeof older.children !== 'function' &&\n    older.children.some(\n      (child) => child === younger || isDescendant(child, younger)\n    )\n  )\n}\n\n/**\n * Get the maximum depth of the children (the depth of the root node is 0).\n *\n * @param {!Object} node - Node in the tree\n * @param {?number} depth - The current depth\n *\n * @return {number} maxDepth - The deepest depth in the tree\n */\nexport function getDepth(node, depth = 0) {\n  if (!node.children) {\n    return depth\n  }\n\n  if (typeof node.children === 'function') {\n    return depth + 1\n  }\n\n  return node.children.reduce(\n    (deepest, child) => Math.max(deepest, getDepth(child, depth + 1)),\n    depth\n  )\n}\n\n/**\n * Find nodes matching a search query in the tree,\n *\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\n * @param {!Object[]} treeData - Tree data\n * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\n * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\n * @param {?number} searchFocusOffset - The offset of the match to focus on\n *                                      (e.g., 0 focuses on the first match, 1 on the second)\n * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\n * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\n *\n * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\n * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\n *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\n *                               it will be the same as the original tree data.\n */\nexport function find({\n  getNodeKey,\n  treeData,\n  searchQuery,\n  searchMethod,\n  searchFocusOffset,\n  expandAllMatchPaths = false,\n  expandFocusMatchPaths = true\n}) {\n  let matchCount = 0\n  const trav = ({ isPseudoRoot = false, node, currentIndex, path = [] }) => {\n    let matches = []\n    let isSelfMatch = false\n    let hasFocusMatch = false\n    // The pseudo-root is not considered in the path\n    const selfPath = isPseudoRoot\n      ? []\n      : [...path, getNodeKey({ node, treeIndex: currentIndex })]\n    const extraInfo = isPseudoRoot\n      ? null\n      : {\n          path: selfPath,\n          treeIndex: currentIndex\n        }\n\n    // Nodes with with children that aren't lazy\n    const hasChildren =\n      node.children &&\n      typeof node.children !== 'function' &&\n      node.children.length > 0\n\n    // Examine the current node to see if it is a match\n    if (!isPseudoRoot && searchMethod({ ...extraInfo, node, searchQuery })) {\n      if (matchCount === searchFocusOffset) {\n        hasFocusMatch = true\n      }\n\n      // Keep track of the number of matching nodes, so we know when the searchFocusOffset\n      //  is reached\n      matchCount += 1\n\n      // We cannot add this node to the matches right away, as it may be changed\n      //  during the search of the descendants. The entire node is used in\n      //  comparisons between nodes inside the `matches` and `treeData` results\n      //  of this method (`find`)\n      isSelfMatch = true\n    }\n\n    let childIndex = currentIndex\n    const newNode = { ...node }\n    if (hasChildren) {\n      // Get all descendants\n      newNode.children = newNode.children.map((child) => {\n        const mapResult = trav({\n          node: child,\n          currentIndex: childIndex + 1,\n          path: selfPath\n        })\n\n        // Ignore hidden nodes by only advancing the index counter to the returned treeIndex\n        // if the child is expanded.\n        //\n        // The child could have been expanded from the start,\n        // or expanded due to a matching node being found in its descendants\n        if (mapResult.node.expanded) {\n          childIndex = mapResult.treeIndex\n        } else {\n          childIndex += 1\n        }\n\n        if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {\n          matches = [...matches, ...mapResult.matches]\n          if (mapResult.hasFocusMatch) {\n            hasFocusMatch = true\n          }\n\n          // Expand the current node if it has descendants matching the search\n          // and the settings are set to do so.\n          if (\n            (expandAllMatchPaths && mapResult.matches.length > 0) ||\n            ((expandAllMatchPaths || expandFocusMatchPaths) &&\n              mapResult.hasFocusMatch)\n          ) {\n            newNode.expanded = true\n          }\n        }\n\n        return mapResult.node\n      })\n    }\n\n    // Cannot assign a treeIndex to hidden nodes\n    if (!isPseudoRoot && !newNode.expanded) {\n      matches = matches.map((match) => ({\n        ...match,\n        treeIndex: null\n      }))\n    }\n\n    // Add this node to the matches if it fits the search criteria.\n    // This is performed at the last minute so newNode can be sent in its final form.\n    if (isSelfMatch) {\n      matches = [{ ...extraInfo, node: newNode }, ...matches]\n    }\n\n    return {\n      node: matches.length > 0 ? newNode : node,\n      matches,\n      hasFocusMatch,\n      treeIndex: childIndex\n    }\n  }\n\n  const result = trav({\n    node: { children: treeData },\n    isPseudoRoot: true,\n    currentIndex: -1\n  })\n\n  return {\n    matches: result.matches,\n    treeData: result.node.children\n  }\n}\n"],"names":["getNodeDataAtTreeIndexOrNextIndex","_ref","targetIndex","node","currentIndex","getNodeKey","_ref$path","path","_ref$lowerSiblingCoun","lowerSiblingCounts","_ref$ignoreCollapsed","ignoreCollapsed","_ref$isPseudoRoot","isPseudoRoot","selfPath","treeIndex","children","expanded","nextIndex","childIndex","childCount","length","i","result","concat","_toConsumableArray","getDescendantCount","_ref2","_ref2$ignoreCollapsed","walkDescendants","_ref3","callback","_ref3$isPseudoRoot","_ref3$parentNode","parentNode","_ref3$path","_ref3$lowerSiblingCou","mapDescendants","_ref4","_ref4$isPseudoRoot","_ref4$parentNode","_ref4$path","_ref4$lowerSiblingCou","nextNode","_objectSpread","selfInfo","map","child","mapResult","walk","_ref7","treeData","_ref7$ignoreCollapsed","_ref8","_ref8$ignoreCollapsed","changeNodeAtPath","_ref12","newNode","_ref12$ignoreCollapse","RESULT_MISS","traverse","_ref13","_ref13$isPseudoRoot","currentTreeIndex","pathIndex","Error","nextTreeIndex","_objectSpread2","slice","addNodeAtDepthAndIndex","_ref21","targetDepth","minimumTreeIndex","expandParent","_ref21$isPseudoRoot","isLastChild","currentDepth","_ref21$path","n","extraNodeProps","insertedTreeIndex","parentPath","insertIndex","pathFragment","newChildren","_ref19","_ref19$parentKey","parentKey","_ref19$ignoreCollapse","_ref19$expandParent","_ref19$addAsFirstChil","addAsFirstChild","hasBeenAdded","changedTreeData","_ref20","key","_ref25","searchQuery","searchMethod","searchFocusOffset","_ref25$expandAllMatch","expandAllMatchPaths","_ref25$expandFocusMat","expandFocusMatchPaths","matchCount","trav","_ref26","_ref26$isPseudoRoot","_ref26$path","matches","isSelfMatch","hasFocusMatch","extraInfo","hasChildren","match","getDepth","depth","reduce","deepest","Math","max","_ref23","_ref23$ignoreCollapse","flattened","nodeInfo","push","_ref17","_ref17$ignoreCollapse","foundNodeInfo","_ref18","err","_ref24","flatData","_ref24$getKey","getKey","id","_ref24$getParentKey","getParentKey","parentId","_ref24$rootKey","rootKey","childrenToParents","forEach","parent","_ref5","total","currentNode","_ref6","index","_ref22","_ref22$getNodeKey","_ref22$ignoreCollapse","_ref22$expandParent","insertResult","isDescendant","older","younger","some","_ref15","_ref15$ignoreCollapse","removedNode","removedTreeIndex","_ref16","_ref14","_ref14$ignoreCollapse","_ref9","_ref9$expanded","_ref10","_ref11"],"mappings":"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"}